--- BEGIN REPOSITORY CONTENTS ---

Generative AI Web App Code Repository

--- BEGIN DIRECTORY OVERVIEW ---
./vite.config.js
./package.json
./server/config/neo4jConfig.js
./server/controllers/ApiCallController.js
./server/controllers/DocBuilderController.js
./server/controllers/DocumentationController.js
./server/controllers/FactController.js
./server/controllers/SchemaController.js
./server/controllers/RepositoryController.js
./server/controllers/DatabaseUtilityController.js
./server/controllers/DocumentController.js
./server/middleware/errorHandler.js
./server/prompts/extractFacts.js
./server/prompts/generateDetailedDocumentation.js
./server/prompts/generateDocumentation.js
./server/prompts/generateMermaidDiagram.js
./server/prompts/organizeFacts.js
./server/prompts/reconcileFacts.js
./server/prompts/documentCreationPrompts.js
./server/repositories/Neo4jApiCallRepository.js
./server/repositories/Neo4jDocumentationRepository.js
./server/repositories/Neo4jFactRepository.js
./server/repositories/Neo4jRepoFileRepository.js
./server/repositories/Neo4jRepository.js
./server/routes/index.js
./server/server.js
./server/services/DocumentationService.js
./server/services/FactService.js
./server/services/FilePathFilter.js
./server/services/FileStatusChecker.js
./server/services/LLMService.js
./server/services/fileUtils.js
./server/services/RepoFileService.js
./server/services/ArtifactChain.js
./server/services/ClaudeApiClient.js
./server/services/DatabaseUtilityService.js
./client/index.html
./client/src/components/DatabaseSchema/DatabaseSchema.jsx
./client/src/components/DatabaseSchema/SchemaViewer.jsx
./client/src/components/DocBuilder/DocBuilder.jsx
./client/src/components/Documentation/Documentation.jsx
./client/src/components/Documentation/DocumentationTab.jsx
./client/src/components/FactGenerator/DataLoader.jsx
./client/src/components/FactGenerator/FactGenerator.jsx
./client/src/components/Inbox/Inbox.jsx
./client/src/components/Layouts/Layout.jsx
./client/src/components/MainContent.jsx
./client/src/components/RepositoryUpload/FileDetailModal.jsx
./client/src/components/RepositoryUpload/RepositoryUpload.jsx
./client/src/components/_atoms/Loader.jsx
./client/src/components/_atoms/Notification.jsx
./client/src/components/_atoms/MermaidDiagram.jsx
./client/src/components/_molecules/FactItem.jsx
./client/src/components/_molecules/InputForm.jsx
./client/src/components/_molecules/MiniSidebar.jsx
./client/src/components/_molecules/PromptEditor.jsx
./client/src/components/_molecules/FileTreeItem.jsx
./client/src/components/_molecules/DocumentCard.jsx
./client/src/components/_molecules/TagSelector.jsx
./client/src/components/_organisms/AppHeader.jsx
./client/src/components/_organisms/FactDisplay.jsx
./client/src/components/_organisms/FactReviewModal.jsx
./client/src/components/_organisms/Sidebar.jsx
./client/src/components/FilterBubbles.jsx
./client/src/components/ResultsTable.jsx
./client/src/hooks/useActiveTab.js
./client/src/hooks/useFactService.js
./client/src/index.jsx
./client/src/pages/DatabaseSchemaPage.jsx
./client/src/pages/DocBuilderPage.jsx
./client/src/pages/DocumentationPage.jsx
./client/src/pages/InboxPage.jsx
./client/src/pages/RepositoryUploadPage.jsx
./client/src/pages/FactGeneratorPage.jsx
./client/src/pages/DatabaseUtilityPage.jsx
./client/src/pages/FilesPage.jsx
./client/src/pages/FilterPage.jsx
./client/src/pages/Artifact.jsx
./client/src/pages/Artifacts.jsx
./client/src/pages/FilePage.jsx
./client/src/App.css
./client/src/lib/utils.js
./client/src/theme.js
./client/src/App.jsx
./client/package.json
./client/postcss.config.js
./client/tailwind.config.js
./client/tsconfig.json
--- END DIRECTORY OVERVIEW ---

--- BEGIN FILE CONTENTS ---

--- FILE: ./vite.config.js ---

<<< BEGIN ./vite.config.js >>>
import { defineConfig } from "vite";
import tailwindcss from "tailwindcss"
import react from "@vitejs/plugin-react";
import path from "path";

export default defineConfig({
  plugins: [react(),tailwindcss()],
  server: {
    host: '0.0.0.0',
    port: 3000,
    hmr: {
      clientPort: 443,
      host: process.env.REPL_SLUG + '.' + process.env.REPL_OWNER + '.repl.co',
      protocol: 'wss',
    },
    proxy: {
      '/api': {
        target: 'http://localhost:3001',
        changeOrigin: true,
        secure: false,
      }
    }
  },
  build: {
    outDir: "../dist/client",
    emptyOutDir: true,
  },
  root: "./client",
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "client/src"),
      shared: path.resolve(__dirname, "shared"),
    },
  },
});
<<< END ./vite.config.js >>>

--- FILE: ./package.json ---

<<< BEGIN ./package.json >>>
{
  "name": "react-javascript",
  "version": "1.0.0",
  "type": "module",
  "description": "React JavaScript on Replit, using Vite bundler",
  "engines": {
    "node": ">=16.0.0"
  },
  "scripts": {
    "dev": "concurrently \"nodemon server/server.js\" \"cd client && vite\"",
    "start": "node server/server.js",
    "build": "cd client && vite build",
    "export": "export/gen_code.sh"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@anthropic-ai/sdk": "^0.27.2",
    "@emotion/react": "^11.13.0",
    "@emotion/styled": "^11.13.0",
    "@mui/icons-material": "^6.0.2",
    "@mui/lab": "^5.0.0-alpha.173",
    "@mui/material": "^6.0.2",
    "@mui/x-tree-view": "^7.13.0",
    "@radix-ui/react-icons": "^1.3.0",
    "axios": "^1.7.3",
    "chalk": "^5.3.0",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "flowbite-react": "^0.10.1",
    "lucide-react": "^0.439.0",
    "mermaid": "^11.1.1",
    "micromatch": "^4.0.8",
    "neo4j-driver": "^5.23.0",
    "posthog-js": "^1.155.4",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-markdown": "^9.0.1",
    "react-router-dom": "^6.0.0",
    "semver": "^7.6.3",
    "shadcn": "^2.0.3",
    "showdown": "^2.1.0",
    "simple-update-notifier": "^2.0.0",
    "tailwind-merge": "^2.5.2",
    "tailwindcss-animate": "^1.0.7"
  },
  "devDependencies": {
    "@types/react": "^18.2.37",
    "@types/react-dom": "^18.2.15",
    "@vitejs/plugin-react": "^4.2.0",
    "autoprefixer": "^10.4.20",
    "concurrently": "^7.6.0",
    "http-proxy-middleware": "^3.0.1",
    "nodemon": "^3.1.4",
    "postcss": "^8.4.45",
    "tailwindcss": "^3.4.10",
    "typescript": "^5.2.2",
    "vite": "^5.0.0"
  }
}

<<< END ./package.json >>>

--- FILE: ./server/config/neo4jConfig.js ---

<<< BEGIN ./server/config/neo4jConfig.js >>>
// File: ./server/config/neo4jConfig.js

import neo4j from "neo4j-driver";
import dotenv from "dotenv";

dotenv.config();

const NEO4J_URI = process.env.NEO4J_URI;
const NEO4J_USER = process.env.NEO4J_USER;
const NEO4J_PASSWORD = process.env.NEO4J_PASSWORD;

if (!NEO4J_URI || !NEO4J_USER || !NEO4J_PASSWORD) {
  console.error("Neo4j credentials are not set in environment variables.");
  process.exit(1);
}

const driver = neo4j.driver(
  NEO4J_URI,
  neo4j.auth.basic(NEO4J_USER, NEO4J_PASSWORD),
);

export default driver;

<<< END ./server/config/neo4jConfig.js >>>

--- FILE: ./server/controllers/ApiCallController.js ---

<<< BEGIN ./server/controllers/ApiCallController.js >>>
// File: ./server/controllers/ApiCallController.js

import Neo4jApiCallRepository from "../repositories/Neo4jApiCallRepository.js";
import logger from "../../shared/logger.js";

class ApiCallController {
  static async getApiCalls(req, res, next) {
    try {
      const limit = parseInt(req.query.limit) || 50;
      const apiCalls = await Neo4jApiCallRepository.getApiCalls(limit);
      res.json(apiCalls);
    } catch (error) {
      logger.error(`Error in ApiCallController.getApiCalls: ${error.message}`);
      next(error);
    }
  }
}

export default ApiCallController;
<<< END ./server/controllers/ApiCallController.js >>>

--- FILE: ./server/controllers/DocBuilderController.js ---

<<< BEGIN ./server/controllers/DocBuilderController.js >>>
// File: ./server/controllers/DocBuilderController.js
import driver from "../config/neo4jConfig.js";
import logger from "../../shared/logger.js";

class DocBuilderController {
  static async getDocument(req, res, next) {
    const session = driver.session();
    try {
      const { title } = req.query;
      logger.debug(`Fetching document with title: ${title}`);

      const result = await session.run(
        `MATCH (d:Document {title: $title})-[:HAS_SECTION]->(s:Section)
         RETURN s.title AS title, s.content AS content, ID(s) AS id
         ORDER BY s.order`,
        { title },
      );

      const sections = result.records.map((record) => ({
        id: record.get("id").toString(),
        title: record.get("title"),
        content: record.get("content"),
      }));

      if (sections.length === 0) {
        logger.debug(`Document with title "${title}" not found`);
        res.status(404).json({ error: "Document not found" });
      } else {
        logger.debug(`Successfully fetched document with title: ${title}`);
        res.json(sections);
      }
    } catch (error) {
      logger.error(`Error fetching document: ${error.message}`);
      next(error);
    } finally {
      await session.close();
    }
  }

  static async updateSection(req, res, next) {
    const session = driver.session();
    try {
      const { sectionId, content } = req.body;
      logger.debug(`Updating section with ID: ${sectionId}`);

      const result = await session.run(
        `MATCH (s:Section)
       WHERE ID(s) = $sectionId
       SET s.content = $content
       RETURN s.title AS title, s.content AS content, ID(s) AS id`,
        { sectionId: parseInt(sectionId), content },
      );

      if (result.records.length === 0) {
        logger.debug(`Section with ID ${sectionId} not found`);
        res.status(404).json({ error: "Section not found" });
      } else {
        const updatedSection = result.records[0].toObject();
        logger.debug(`Successfully updated section with ID: ${sectionId}`);
        res.json(updatedSection);
      }
    } catch (error) {
      logger.error(`Error updating section: ${error.message}`);
      next(error);
    } finally {
      await session.close();
    }
  }
}

export default DocBuilderController;
<<< END ./server/controllers/DocBuilderController.js >>>

--- FILE: ./server/controllers/DocumentationController.js ---

<<< BEGIN ./server/controllers/DocumentationController.js >>>
import DocumentationService from "../services/DocumentationService.js";
import logger from "../../shared/logger.js";

class DocumentationController {
  static async getDocumentation(req, res, next) {
    try {
      logger.debug("Fetching documentation");
      const documentation = await DocumentationService.getDocumentation();
      res.json({ documentation });
    } catch (error) {
      logger.error(`Error fetching documentation: ${error.message}`);
      next(error);
    }
  }

  static async refreshDocumentation(req, res, next) {
    try {
      logger.debug("Refreshing documentation");
      const result = await DocumentationService.refreshDocumentation();
      res.json({ message: result });
    } catch (error) {
      logger.error(`Error refreshing documentation: ${error.message}`);
      next(error);
    }
  }
}

export default DocumentationController;
<<< END ./server/controllers/DocumentationController.js >>>

--- FILE: ./server/controllers/FactController.js ---

<<< BEGIN ./server/controllers/FactController.js >>>
// File: ./server/controllers/FactController.js

import FactService from "../services/FactService.js";
import RepoFileService from "../services/RepoFileService.js";
import logger from "../../shared/logger.js";

class FactController {
  static async getFacts(req, res, next) {
    try {
      logger.debug("Fetching facts");
      const facts = await FactService.getFacts();
      res.json({ facts });
    } catch (error) {
      logger.error(`Error fetching facts: ${error.message}`);
      next(error);
    }
  }

  static async processFacts(req, res, next) {
    try {
      const { input } = req.body;
      logger.debug(`Processing facts from input: ${input.substring(0, 50)}...`);

      if (!input || typeof input !== "string") {
        const error = new Error("Invalid input. Expected a non-empty string.");
        error.statusCode = 400;
        throw error;
      }

      const result = await FactService.processFacts(input);
      logger.debug(
        `Facts processed: ${JSON.stringify(result).substring(0, 100)}...`,
      );

      res.json({ result });
    } catch (error) {
      logger.error(`Error processing facts: ${error.message}`);
      next(error);
    }
  }

  static async extractFacts(req, res, next) {
    try {
      const { input } = req.body;
      const extractedFacts = await FactService.extractFacts(input);
      res.json({ extractedFacts });
    } catch (error) {
      logger.error(`Error extracting facts: ${error.message}`);
      next(error);
    }
  }

  static async reconcileFacts(req, res, next) {
    try {
      const { currentFacts, newFacts } = req.body;
      const reconciled = await FactService.reconcileFacts(
        currentFacts,
        newFacts,
      );
      res.json({ reconciled });
    } catch (error) {
      logger.error(`Error reconciling facts: ${error.message}`);
      next(error);
    }
  }

  static async organizeFacts(req, res, next) {
    try {
      const { facts } = req.body;
      const organized = await FactService.organizeFacts(facts);
      res.json({ organized });
    } catch (error) {
      logger.error(`Error organizing facts: ${error.message}`);
      next(error);
    }
  }

  static async finalizeReviewedFacts(req, res, next) {
    try {
      const { reviewedFacts } = req.body;
      logger.debug(
        `Finalizing reviewed facts: ${JSON.stringify(reviewedFacts).substring(0, 100)}...`,
      );

      const finalizedFacts =
        await FactService.finalizeFactsAndSave(reviewedFacts);
      logger.debug(
        `Facts finalized and saved: ${finalizedFacts.substring(0, 100)}...`,
      );

      res.json({ facts: finalizedFacts });
    } catch (error) {
      logger.error(`Error finalizing reviewed facts: ${error.message}`);
      next(error);
    }
  }

  static async getRepositoryFiles(req, res, next) {
    try {
      const files = await RepoFileService.getRepositoryFiles();
      res.json({ files });
    } catch (error) {
      logger.error(`Error getting repository files: ${error.message}`);
      next(error);
    }
  }

  static async uploadRepositoryFile(req, res, next) {
    try {
      const { file } = req.body;
      const result = await RepoFileService.uploadFile(file);
      res.json(result);
    } catch (error) {
      logger.error(`Error uploading repository file: ${error.message}`);
      next(error);
    }
  }
}

export default FactController;

<<< END ./server/controllers/FactController.js >>>

--- FILE: ./server/controllers/SchemaController.js ---

<<< BEGIN ./server/controllers/SchemaController.js >>>
// File: ./server/controllers/SchemaController.js
import driver from "../config/neo4jConfig.js";
import logger from "../../shared/logger.js";

class SchemaController {
  static async getSchema(req, res, next) {
    const session = driver.session();
    try {
      logger.debug("Fetching database schema");

      const result = await session.run(`
        CALL db.schema.visualization()
      `);

      const nodes = result.records[0].get("nodes");
      const relationships = result.records[0].get("relationships");

      const schema = {
        nodes: nodes.map((node) => ({
          labels: node.labels,
          properties: Object.keys(node.properties),
        })),
        relationships: relationships.map((rel) => ({
          type: rel.type,
          startNodeLabels: rel.start.labels,
          endNodeLabels: rel.end.labels,
          properties: Object.keys(rel.properties),
        })),
      };

      res.json(schema);
    } catch (error) {
      logger.error(`Error fetching database schema: ${error.message}`);
      next(error);
    } finally {
      await session.close();
    }
  }
}

export default SchemaController;

<<< END ./server/controllers/SchemaController.js >>>

--- FILE: ./server/controllers/RepositoryController.js ---

<<< BEGIN ./server/controllers/RepositoryController.js >>>
// File: ./server/controllers/RepositoryController.js

import RepoFileService from "../services/RepoFileService.js";
import Neo4jRepoFileRepository from "../repositories/Neo4jRepoFileRepository.js";
import logger from "../../shared/logger.js";

class RepositoryController {
  static async getRepositoryFiles(req, res, next) {
    try {
      logger.debug("Getting all repository files");
      const limit = req.params.limit ?? 10;
      const page = req.params.page ?? 1;
      const result = await RepoFileService.getRepositoryFiles(limit,page);
      res.json(result);
    } catch (error) {
      logger.error(`Error getting repository files: ${error.message}`);
      next(error);
    }
  }

  static async refreshFile(req, res, next) {
    try {
      const { filePath } = req.body;
      logger.debug(`Refreshing file: ${filePath}`);
      const result = await RepoFileService.refreshFile(filePath);
      res.json(result);
    } catch (error) {
      logger.error(`Error refreshing file: ${error.message}`);
      next(error);
    }
  }

  static async deleteFile(req, res, next) {
    try {
      const { filePath } = req.body;
      logger.debug(`Deleting file from database: ${filePath}`);
      const result = await RepoFileService.deleteFile(filePath);
      res.json(result);
    } catch (error) {
      logger.error(`Error deleting file from database: ${error.message}`);
      next(error);
    }
  }

  static async refreshFolder(req, res, next) {
    try {
      const { folderPath } = req.body;
      logger.debug(`Refreshing folder: ${folderPath}`);
      const result = await RepoFileService.refreshFolder(folderPath);
      res.json(result);
    } catch (error) {
      logger.error(`Error refreshing folder: ${error.message}`);
      next(error);
    }
  }

  static async deleteFolder(req, res, next) {
    try {
      const { folderPath } = req.body;
      logger.debug(`Deleting folder from database: ${folderPath}`);
      const result = await RepoFileService.deleteFolder(folderPath);
      res.json(result);
    } catch (error) {
      logger.error(`Error deleting folder from database: ${error.message}`);
      next(error);
    }
  }

  static async getFileDetails(req, res, next) {
    try {
      const { filePath } = req.params;
      logger.debug(`Getting file details for: ${filePath}`);
      const file = await Neo4jRepoFileRepository.getFile(filePath);
      if (!file) {
        logger.warn(`File not found: ${filePath}`);
        return res.status(404).json({ error: "File not found" });
      }
      logger.debug(`Successfully retrieved file details for: ${filePath}`);
      res.json({
        documentation: file.documentation,
        relatedFiles:file.relatedFiles
        // Include other file details as needed
      });
    } catch (error) {
      logger.error(`Error getting file details: ${error.message}`);
      next(error);
    }
  }

  static async generateMermaidDiagram(req, res, next) {
    try {
      const { filePath } = req.params;
      logger.debug(`Generating Mermaid diagram for file: ${filePath}`);
      const file = await Neo4jRepoFileRepository.getFile(filePath);
      if (!file) {
        logger.warn(`File not found: ${filePath}`);
        return res.status(404).json({ error: "File not found" });
      }
      if (!file.documentation.mermaid_diagram) {
        logger.warn(`Mermaid diagram not found for file: ${filePath}`);
        return res
          .status(404)
          .json({ error: "Mermaid diagram not found for this file" });
      }
      logger.debug(
        `Successfully generated Mermaid diagram for file: ${filePath}`
      );
      res.json({ mermaidDiagram: file.documentation.mermaid_diagram });
    } catch (error) {
      logger.error(`Error generating Mermaid diagram: ${error.message}`);
      next(error);
    }
  }
}

export default RepositoryController;
<<< END ./server/controllers/RepositoryController.js >>>

--- FILE: ./server/controllers/DatabaseUtilityController.js ---

<<< BEGIN ./server/controllers/DatabaseUtilityController.js >>>
// File: ./server/controllers/DatabaseUtilityController.js

import DatabaseUtilityService from '../services/DatabaseUtilityService.js';
import logger from '../../shared/logger.js';

class DatabaseUtilityController {

  static async getFilterBubbles(req, res, next) {
    try {
      logger.debug('Fetching filter bubbles');
      const bubbles = await DatabaseUtilityService.getFilterBubbles();
      res.json(bubbles);
    } catch (error) {
      logger.error(`Error fetching filter bubbles: ${error.message}`);
      next(error);
    }
  }
  
  static async applyFilters(req, res, next) {
    try {
      const { filters } = req.body;
      const results = await DatabaseUtilityService.applyFilters(filters);
      const updatedFilters = await DatabaseUtilityService.getUpdatedFilterCounts(filters);
      res.json({ results, updatedFilters });
    } catch (error) {
      logger.error(`Error applying filters: ${error.message}`);
      res.status(500).json({ error: 'An error occurred while applying filters' });
    }
  }
  
  static async getTags(req, res, next) {
    try {
      logger.debug('DatabaseUtilityController: Fetching all unique tags');
      const tags = await DatabaseUtilityService.getTags();
      res.json(tags);
    } catch (error) {
      logger.error(`Error in getTags: ${error.message}`);
      next(error);
    }
  }
}

export default DatabaseUtilityController;
<<< END ./server/controllers/DatabaseUtilityController.js >>>

--- FILE: ./server/controllers/DocumentController.js ---

<<< BEGIN ./server/controllers/DocumentController.js >>>
import { callClaude } from "../services/ClaudeApiClient.js";
import logger from "../../shared/logger.js";
import driver from "../config/neo4jConfig.js";
import createArtifactCreationChain from "../services/ArtifactChain.js";
import Neo4jRepository from "../repositories/Neo4jRepository.js";

class DocumentController {
  static async getDocuments(req, res, next) {
    const session = driver.session();
    try {
      const result = await session.run(
        `MATCH (d:Document)
        WHERE d.active IS NULL OR d.active <> false
        WITH d
        ORDER BY d.createdAt DESC
        WITH d.id AS id
        MATCH (d:Document {id: id})
        WITH id, collect(d) as versions
        WITH id, versions[0] as latestVersion, versions[1..] as olderVersions
        RETURN {
          id: id,
          document: latestVersion,
          versions: olderVersions
        } as documentWithVersions
        ORDER BY latestVersion.createdAt DESC`,
      );

      const documents = result.records.map((record) => {
        const documentWithVersions = record.get("documentWithVersions");
        const latestVersion = documentWithVersions.document.properties;
        const olderVersions = documentWithVersions.versions.map(
          (v) => v.properties,
        );

        return {
          document: {
            id: latestVersion.id,
            title: latestVersion.title,
            prompt: latestVersion.prompt,
            version: latestVersion.version,
            documentation: latestVersion.documentation,
            tags: JSON.parse(latestVersion.tags || '[]'),
            lastModified: Neo4jRepository.convertCypherDateToJsDate(
              latestVersion.updatedAt,
            ),
          },
          versions: olderVersions.map((v) => ({
            id: v.id,
            title: v.title,
            prompt: v.prompt,
            version: v.version,
            documentation: v.documentation,
            tags: JSON.parse(v.tags || '[]'),
            lastModified: Neo4jRepository.convertCypherDateToJsDate(
              v.updatedAt,
            ),
          })),
        };
      });
      res.json(documents);
    } catch (error) {
      logger.error(`Error fetching documents: ${error.message}`);
      next(error);
    } finally {
      await session.close();
    }
  }

  static async getDocument(req, res, next) {
    const session = driver.session();
    try {
      const { id } = req.params;
      const result = await session.run(
        `MATCH (d:Document {id: $id})
         WITH d ORDER BY d.version DESC
         WITH collect(d) as versionArray
         WITH versionArray[0] as latestVersion, versionArray[1..] as versions
         RETURN latestVersion as document, versions`,
        { id },
      );

      if (result.records.length === 0) {
        return res.status(404).json({ error: "Document not found" });
      }

      const document = result.records[0].get("document").properties;
      const versions = result.records[0]
        .get("versions")
        .map((node) => node.properties);

      res.json({
        document: {
          ...document,
          tags: JSON.parse(document.tags || '[]'),
        },
        versions: versions.map(v => ({
          ...v,
          tags: JSON.parse(v.tags || '[]'),
        })),
      });
    } catch (error) {
      logger.error(`Error fetching document: ${error.message}`);
      next(error);
    } finally {
      await session.close();
    }
  }

  static async createDocument(req, res, next) {
    const session = driver.session();
    try {
      const { title, prompt, tags } = req.body;
      const artifactCreationChain = await createArtifactCreationChain();
      const newDocument = await artifactCreationChain({ title, prompt, tags });
      res.status(201).json(newDocument);
    } catch (error) {
      logger.error(`Error creating document: ${error.message}`);
      next(error);
    } finally {
      await session.close();
    }
  }

  static async updateDocument(req, res, next) {
    const session = driver.session();
    try {
      const { id } = req.params;
      const { title, prompt, tags } = req.body;

      // Fetch the existing document to ensure it exists
      const existingDoc = await session.run(
        "MATCH (d:Document {id: $id}) RETURN d",
        { id },
      );

      if (existingDoc.records.length === 0) {
        return res.status(404).json({ error: "Document not found" });
      }

      const artifactCreationChain = await createArtifactCreationChain();
      const updatedDocument = await artifactCreationChain({
        id,
        title,
        prompt,
        tags,
      });

      res.json(updatedDocument);
    } catch (error) {
      logger.error(`Error updating document: ${error.message}`);
      next(error);
    } finally {
      await session.close();
    }
  }

  static async deleteDocument(req, res, next) {
    const session = driver.session();
    try {
      const { id } = req.params;
      await session.run("MATCH (d:Document {id: $id}) SET d.active = false", {
        id,
      });
      res.json({ message: "Document deleted successfully" });
    } catch (error) {
      logger.error(`Error deleting document: ${error.message}`);
      next(error);
    } finally {
      await session.close();
    }
  }
}

export default DocumentController;
<<< END ./server/controllers/DocumentController.js >>>

--- FILE: ./server/middleware/errorHandler.js ---

<<< BEGIN ./server/middleware/errorHandler.js >>>
import logger from "../../shared/logger.js";

const errorHandler = (err, req, res, next) => {
  logger.error(`Error details: ${err.message}`);
  logger.error(`Stack trace: ${err.stack}`);

  const statusCode = err.statusCode || 500;
  const message = "An error occurred while processing your request.";

  res.status(statusCode).json({
    error: {
      message: message,
    },
  });
};

export default errorHandler;

<<< END ./server/middleware/errorHandler.js >>>

--- FILE: ./server/prompts/extractFacts.js ---

<<< BEGIN ./server/prompts/extractFacts.js >>>
export const extractFactsPrompt = `
Given the following text, extract a list of distinct facts:

{input}

Please provide a numbered list of distinct facts from the text above. Each fact should be a single, concise statement.
`;

<<< END ./server/prompts/extractFacts.js >>>

--- FILE: ./server/prompts/generateDetailedDocumentation.js ---

<<< BEGIN ./server/prompts/generateDetailedDocumentation.js >>>
export const generateDetailedDocumentationPrompt = `
Given the following list of files and their contents from a software repository, your job is to create a detailed documentation overview in markdown format. 
{additionalInstructions}

Here are the files in the repository with their contents:

{fileDetails}

Please generate the documentation based on this information, keeping it concise yet informative.
`;
<<< END ./server/prompts/generateDetailedDocumentation.js >>>

--- FILE: ./server/prompts/generateDocumentation.js ---

<<< BEGIN ./server/prompts/generateDocumentation.js >>>
export const generateDocumentationPrompt = `
Given the following list of files from a software repository, create a concise documentation overview in markdown format. Focus on key components and structures, providing moderate detail without going into specifics of each function. Your documentation should:

1. Start with a brief introduction of the project's purpose.
2. Outline the main directories and their purposes.
3. Highlight key files and their roles in the system.
4. Describe the overall architecture and any notable design patterns used.
5. Mention any important dependencies or technologies used.
6. Conclude with a brief summary of the project's current state and any notable features.

Here are the files in the repository:

{fileList}

Please generate the documentation based on this information, keeping it concise yet informative.
`;

<<< END ./server/prompts/generateDocumentation.js >>>

--- FILE: ./server/prompts/generateMermaidDiagram.js ---

<<< BEGIN ./server/prompts/generateMermaidDiagram.js >>>
// File: ./server/prompts/generateMermaidDiagram.js

export default `
Given the details below, generate a Mermaid diagram that represents the internal structure and processes. Capture all relevant elements such as functions, classes, conditionals, and loops.

<TASK_INSTRUCTIONS>
Generate the diagram using the correct Mermaid syntax, starting directly with the diagram type (e.g., flowchart TD, classDiagram). The output should include only the Mermaid code.

IMPORTANT: Do not include any prefixes, markdown formatting, or code block syntax. Return only the Mermaid code starting with the diagram type declaration.

Correct Output Example:
flowchart TD
    A[Start] --> B{Condition}
    B -->|Yes| C[Process 1]
    B -->|No| D[Process 2]
    C --> E[End]
    D --> E

Incorrect Output Example:
'''mermaid
flowchart TD
    A[Start] --> B{Condition}
    B -->|Yes| C[Process 1]
    B -->|No| D[Process 2]
    C --> E[End]
    D --> E

Ensure the output matches the correct example format.
</TASK_INSTRUCTIONS>

<FILE_DETAILS>
File Type: {fileType}
File Content:
{fileContent}
</FILE_DETAILS>
`;

<<< END ./server/prompts/generateMermaidDiagram.js >>>

--- FILE: ./server/prompts/organizeFacts.js ---

<<< BEGIN ./server/prompts/organizeFacts.js >>>
export const organizeFactsPrompt = `
Given the following list of facts, reorganize them in the most logical order while maintaining them as a single, ungrouped list. Present the facts in bulleted markdown format without adding section headers or any other text.

{facts}
`;

<<< END ./server/prompts/organizeFacts.js >>>

--- FILE: ./server/prompts/reconcileFacts.js ---

<<< BEGIN ./server/prompts/reconcileFacts.js >>>
export const reconcileFactsPrompt = `
You are an AI assistant tasked with comparing two sets of facts: previous facts and new facts. Categorize facts as SUSTAINED, NEW, or CONFLICTS based on the following guidelines:

1) SUSTAINED: Facts from the previous set that are not contradicted, made obsolete, or significantly updated by new facts. This also includes duplicate information where the new fact is identical to an existing fact.
2) NEW: New facts that add information without directly conflicting with previous facts but may require user review for confirmation.
3) CONFLICTS: New facts that directly contradict, reverse, or significantly alter the meaning of previous facts. These should be flagged for user decision.

### Fact Classification Process:
- **Break Apart Facts**: Separate different aspects of a fact when possible to sustain non-conflicting parts and isolate the conflicting or new elements for further review.
- **User Review for New Information**: Present new facts that could either complement or clarify existing information but require user confirmation.
- **User Decision on Conflicts**: When a new fact directly contradicts a previously sustained fact, prompt the user to choose which fact should be sustained.

### Example Scenario:
- Previous fact: "Royal Caribbean International (RCI) was previously known as Royal Caribbean Cruise Line (RCCL)."
  - **Result**: "RCI was previously known as RCCL" is sustained.
- New fact: "Royal Caribbean International is only known as Royal Caribbean Cruise Line internationally."
  - **Result**: Flagged as NEW and presented for user review.
- Conflicting fact: "Royal Caribbean International is still known as Royal Caribbean Cruise Line."
  - **Result**: Flagged as CONFLICT, prompting the user to decide which understanding should be sustained.

Return ONLY a JSON object with the following structure:
{
  "sustained": [
    {"id": "s1", "fact": "Sustained fact text"}
  ],
  "new": [
    {"id": "n1", "fact": "New fact text"}
  ],
  "conflicts": [
    {
      "id": "c1",
      "newFact": "New conflicting fact",
      "oldFact": "Existing fact it conflicts with",
      "explanation": "Brief explanation of the conflict (max 5 words)",
      "userPrompt": "Ask the user to decide which fact should be sustained."
    }
  ]
}

Ensure:
- Every previous fact is either in "sustained" or has one or more corresponding "conflicts" entries.
- Every new fact is either in "new" or in "conflicts", but never in both.
- Duplicate facts should be categorized as "sustained."
- If any conflict related to a previous fact is accepted, that previous fact should be removed from "sustained."
- Do not include any text outside the JSON object.
- Use the exact keys and structure shown above.

Analyze the following sets of facts:

Previous facts:
<previous_facts>
{previousFacts}
</previous_facts>

New facts:
<new_facts>
{newFacts}
</new_facts>

Respond with the JSON object only.
`;

<<< END ./server/prompts/reconcileFacts.js >>>

--- FILE: ./server/prompts/documentCreationPrompts.js ---

<<< BEGIN ./server/prompts/documentCreationPrompts.js >>>
// File: ./server/prompts/documentCreationPrompts.js

export const cypherGenerationPrompt = `
Given the following prompt and database schema, generate a Cypher query to fetch relevant information from the database:

Prompt: {prompt}

Database Schema:
{schema}

Your task is to create a Cypher query that retrieves information relevant to the prompt. The query should:
1. Identify and match relevant nodes and relationships based on the prompt and schema.
2. Include appropriate WHERE clauses to filter the results.
3. Return relevant properties and relationships.
4. Limit the results to a reasonable number (e.g., 10-20) to avoid overwhelming responses.

Please provide only the Cypher query without any explanation or additional text.
`;

export const cypherEvaluationPrompt = `
Evaluate and improve the following Cypher query based on the given prompt, schema, and any previous errors:

Prompt: {prompt}

Database Schema:
{schema}

Current Cypher query:
{cypher}

Previous errors (if any):
{errors}

Your task is to:
1. Identify any syntax errors or logical issues in the query.
2. Ensure the query correctly addresses the prompt and uses the schema appropriately.
3. Optimize the query for performance if possible.
4. If there are errors, fix them and provide an improved query.
5. If there are no errors and no improvements needed, return the original query.

Please respond with a JSON object in the following format:
{
  "errors": ["List of identified errors or an empty array if none"],
  "cypher": "The improved or original Cypher query"
}
`;

export const documentCreationPrompt = `
You are an AI assistant tasked with creating a detailed document based on a user's prompt and the context from a software repository database. Your goal is to produce a comprehensive response that directly addresses the user's prompt while incorporating relevant information from the provided context.

User Prompt: {prompt}

Context (retrieved from the database):
{context}

Instructions:
1. Carefully analyze the user's prompt and the provided context.
2. Create a well-structured and detailed document that directly addresses the user's prompt.
3. Incorporate relevant information from the context, ensuring accuracy and coherence.
4. Use appropriate headings, subheadings, and formatting to organize the content.
5. If the user's prompt is a question, make sure to answer it thoroughly.
6. If the user's prompt is a task or request, fulfill it to the best of your ability using the available context.
7. Include code snippets, explanations, or examples from the context when relevant to the prompt.
8. If the prompt requires comparisons or analysis across multiple files, make sure to synthesize information from different parts of the context.
9. Provide citations or references to the specific files in the context used, where appropriate.
10. The citations should be markdown links with URL format of '/files/repo_filepath'. The repo file_path should be URL encoded in the link part, but the link text should not be encoded.

Document Structure:
- Start with a brief introduction that restates the user's prompt and outlines how you'll address it.
- Organize the main body of the document with clear headings and subheadings that relate directly to aspects of the user's prompt.
- Include a conclusion that summarizes how you've addressed the user's prompt and any key takeaways.

Citation Example:
If you reference a file "server/config/neo4jConfig.js", the citation should look like:
[server/config/neo4jConfig.js](/files/server%2Fconfig%2Fneo4jConfig.js)

Remember:
- Stay focused on addressing the user's prompt throughout the document.
- Use all relevant information from the context, but don't include irrelevant details.
- If the context doesn't contain information needed to fully address the prompt, clearly state what information is missing or unavailable.
- Ensure the document is coherent, well-structured, and tailored specifically to the user's prompt.

Please generate the document content without any additional explanation or metadata. The content should be ready to be saved as the 'documentation' field of a document node.
`;

export const saveDocumentCypher = `
CREATE (d:Document {
  id: $document.id,
  title: $document.title,
  prompt: $document.prompt,
  createdAt: datetime($document.createdAt),
  updatedAt: datetime($document.updatedAt),
  documentation: $document.documentation,
  tags:$document.tags,
  version: $document.version
})
WITH d
UNWIND $contextFilePaths AS contextFilePath
MATCH (c) WHERE c.file_path = contextFilePath
CREATE (d)-[:BASED_ON]->(c)
RETURN d.id AS documentId
`;

export const updateDocumentCypher = `
MATCH (d:Document {id: $id})
CREATE (newD:Document {
  id: $newDocument.id,
  title: $newDocument.title,
  prompt: $newDocument.prompt,
  createdAt: datetime($newDocument.createdAt),
  updatedAt: datetime($newDocument.updatedAt),
  documentation: $newDocument.documentation,
  tags: $newDocument.tags,
  version: $newDocument.version
})
CREATE (d)-[:PREVIOUS_VERSION]->(newD)
WITH newD
UNWIND $contextFilePaths AS contextFilePath
MATCH (c) WHERE c.file_path = contextFilePath
CREATE (newD)-[:BASED_ON]->(c)
RETURN newD.id AS documentId
`;
<<< END ./server/prompts/documentCreationPrompts.js >>>

--- FILE: ./server/repositories/Neo4jApiCallRepository.js ---

<<< BEGIN ./server/repositories/Neo4jApiCallRepository.js >>>
// File: ./server/repositories/Neo4jApiCallRepository.js

import driver from "../config/neo4jConfig.js";
import logger from "../../shared/logger.js";

class Neo4jApiCallRepository {
  static async saveApiCall(apiCall) {
    const session = driver.session();
    try {
      // Format the timestamp to ISO 8601 format
      const formattedTimestamp = apiCall.timestamp.toISOString();

      await session.run(
        `
        CREATE (a:ApiCall {
          timestamp: datetime($timestamp),
          inputTokens: $inputTokens,
          outputTokens: $outputTokens,
          message: $message
        })
        `,
        {
          ...apiCall,
          timestamp: formattedTimestamp
        }
      );
      logger.debug(`API call record saved: ${JSON.stringify(apiCall)}`);
    } catch (error) {
      logger.error(`Error saving API call record: ${error.message}`);
      throw error;
    } finally {
      await session.close();
    }
  }

  static async getApiCalls(limit = 50) {
    const session = driver.session();
    try {
      const result = await session.run(
        `
        MATCH (a:ApiCall)
        RETURN a
        ORDER BY a.timestamp DESC
        LIMIT toInteger($limit)
        `,
        { limit: limit }
      );
      return result.records.map(record => {
        const properties = record.get('a').properties;
        // Convert Neo4j datetime back to JavaScript Date
        properties.timestamp = new Date(properties.timestamp);
        return properties;
      });
    } catch (error) {
      logger.error(`Error fetching API call records: ${error.message}`);
      throw error;
    } finally {
      await session.close();
    }
  }
}
  
export default Neo4jApiCallRepository;
  
<<< END ./server/repositories/Neo4jApiCallRepository.js >>>

--- FILE: ./server/repositories/Neo4jDocumentationRepository.js ---

<<< BEGIN ./server/repositories/Neo4jDocumentationRepository.js >>>
import driver from "../config/neo4jConfig.js";
import logger from "../../shared/logger.js";

class Neo4jDocumentationRepository {
  static async getDocumentation() {
    const session = driver.session();
    try {
      const result = await session.run(
        "MATCH (d:Documentation) RETURN d.content AS content, d.updated_at AS updated_at",
      );
      const record = result.records[0];
      return record
        ? {
            content: record.get("content"),
            updated_at: record.get("updated_at"),
          }
        : null;
    } catch (error) {
      logger.error(
        `Neo4jDocumentationRepository: Error fetching documentation: ${error.message}`,
      );
      throw error;
    } finally {
      await session.close();
    }
  }

  static async saveDocumentation(content) {
    const session = driver.session();
    try {
      await session.run(
        `MERGE (d:Documentation)
         ON CREATE SET d.content = $content, d.created_at = datetime(), d.updated_at = datetime()
         ON MATCH SET d.content = $content, d.updated_at = datetime()`,
        { content },
      );
      return "Documentation saved successfully";
    } catch (error) {
      logger.error(
        `Neo4jDocumentationRepository: Error saving documentation: ${error.message}`,
      );
      throw error;
    } finally {
      await session.close();
    }
  }
}

export default Neo4jDocumentationRepository;

<<< END ./server/repositories/Neo4jDocumentationRepository.js >>>

--- FILE: ./server/repositories/Neo4jFactRepository.js ---

<<< BEGIN ./server/repositories/Neo4jFactRepository.js >>>
// File: ./server/repositories/Neo4jFactRepository.js

import driver from "../config/neo4jConfig.js";
import logger from "../../shared/logger.js";

class Neo4jFactRepository {
  static async getData() {
    const session = driver.session();
    try {
      const result = await session.run(
        'MATCH (f:RawFact {raw_fact_id: "007"}) RETURN f.content AS content',
      );
      const content = result.records[0]?.get("content");
      return { ok: true, value: content || "" };
    } catch (error) {
      logger.error(
        `Neo4jFactRepository: Error fetching data: ${error.message}`,
      );
      throw error;
    } finally {
      await session.close();
    }
  }

  static async saveData(facts) {
    const session = driver.session();
    try {
      await session.run(
        `MERGE (f:RawFact {raw_fact_id: "007"})
         ON CREATE SET f.content = $facts, f.creation_date = datetime()
         ON MATCH SET f.content = $facts, f.last_updated = datetime()`,
        { facts },
      );
      return "Facts saved successfully in Neo4j";
    } catch (error) {
      logger.error(`Neo4jFactRepository: Error saving data: ${error.message}`);
      throw error;
    } finally {
      await session.close();
    }
  }
}

export default Neo4jFactRepository;

<<< END ./server/repositories/Neo4jFactRepository.js >>>

--- FILE: ./server/repositories/Neo4jRepoFileRepository.js ---

<<< BEGIN ./server/repositories/Neo4jRepoFileRepository.js >>>
// File: ./server/repositories/Neo4jRepoFileRepository.js

import driver from "../config/neo4jConfig.js";
import logger from "../../shared/logger.js";

class Neo4jRepoFileRepository {
  static async getAllFiles(limit = 10, skip = 0) {
    const session = driver.session();
    try {
      const query = `
        MATCH (f:RepoFile)
        RETURN f
        ORDER BY f.created_at DESC
        SKIP toInteger($skip)
        LIMIT toInteger($limit)
      `;
      const result = await session.run(query, { limit: limit, skip: skip });

      return result.records.map((record) => {
        const file = record.get("f").properties;
        return file;
      });
    } catch (error) {
      logger.error(
        `Neo4jRepoFileRepository: Error fetching files: ${error.message}`,
      );
      throw new Error(`Failed to fetch files: ${error.message}`);
    } finally {
      await session.close();
    }
  }

  static async saveFile(file) {
    const session = driver.session();
    try {
      await session.run(
        `
        MERGE (f:RepoFile {file_path: $file_path})
        ON CREATE SET 
          f.file_name = $file_name,
          f.file_content = $file_content,
          f.file_size = $file_size,
          f.created_at = datetime(),
          f.modified_at = datetime(),
          f.documentation = $documentation,
          f.mermaid_diagram = $mermaid_diagram
        ON MATCH SET
          f.file_name = $file_name,
          f.file_content = $file_content,
          f.file_size = $file_size,
          f.modified_at = datetime(),
          f.documentation = $documentation,
          f.mermaid_diagram = $mermaid_diagram
        `,
        file,
      );
      logger.debug(
        `File ${file.file_path} saved in Neo4j with documentation and Mermaid diagram`,
      );
    } catch (error) {
      logger.error(
        `Neo4jRepoFileRepository: Error saving file: ${error.message}`,
      );
      throw error;
    } finally {
      await session.close();
    }
  }

  static async deleteFile(filePath) {
    const session = driver.session();
    try {
      await session.run("MATCH (f:RepoFile {file_path: $filePath}) DELETE f", {
        filePath,
      });
      logger.debug(`File ${filePath} deleted from Neo4j`);
    } catch (error) {
      logger.error(
        `Neo4jRepoFileRepository: Error deleting file: ${error.message}`,
      );
      throw error;
    } finally {
      await session.close();
    }
  }

  static async getFile(filePath) {
    const session = driver.session();
    try {
      logger.debug(`Fetching file from Neo4j: ${filePath}`);
      const result = await session.run(
        `
        MATCH (f:RepoFile {file_path: $filePath})
        OPTIONAL MATCH (f)-[:RELATED_TO]-(related:RepoFile)
        RETURN f AS file, collect(DISTINCT related) AS relatedFiles
        `,
        { filePath }
      );
      const file = result.records[0]?.get("file").properties;
      const relatedFiles = result.records[0]?.get('relatedFiles').map(rel => rel.properties);
      if (file) {
       logger.debug(`File found: ${filePath} with ${relatedFiles.length} related files`);
      } else {
        logger.warn(`File not found: ${filePath}`);
      }
      return { documentation:file, relatedFiles };
    } catch (error) {
      logger.error(
        `Neo4jRepoFileRepository: Error fetching file: ${error.message}`,
      );
      throw error;
    } finally {
      await session.close();
    }
  }

  static async getFileModificationTime(filePath) {
    const session = driver.session();
    try {
      const result = await session.run(
        "MATCH (f:RepoFile {file_path: $filePath}) RETURN f.modified_at",
        { filePath }
      );
      return result.records[0]?.get("f.modified_at");
    } catch (error) {
      logger.error(
        `Neo4jRepoFileRepository: Error fetching file modification time: ${error.message}`,
      );
      throw error;
    } finally {
      await session.close();
    }
  }

  static async updateChangedFiles(files) {
    const session = driver.session();
    try {
      await session.writeTransaction(async (tx) => {
        for (const file of files) {
          await tx.run(
            `
            MERGE (f:RepoFile {file_path: $file_path})
            ON CREATE SET 
              f.file_name = $file_name,
              f.file_content = $file_content,
              f.file_size = $file_size,
              f.created_at = datetime(),
              f.modified_at = datetime(),
              f.documentation = $documentation,
              f.mermaid_diagram = $mermaid_diagram
            ON MATCH SET
              f.file_name = $file_name,
              f.file_content = $file_content,
              f.file_size = $file_size,
              f.modified_at = datetime(),
              f.documentation = $documentation,
              f.mermaid_diagram = $mermaid_diagram
            `,
            file
          );
        }
      });
      logger.debug(`Updated ${files.length} changed files in Neo4j`);
    } catch (error) {
      logger.error(
        `Neo4jRepoFileRepository: Error updating changed files: ${error.message}`,
      );
      throw error;
    } finally {
      await session.close();
    }
  }

  static async deleteFolderContents(folderPath) {
    const session = driver.session();
    try {
      const result = await session.run(
        `
        MATCH (f:RepoFile)
        WHERE f.file_path STARTS WITH $folderPath
        WITH f
        OPTIONAL MATCH (f)-[r]-()
        DELETE f, r
        RETURN count(f) as deletedCount
        `,
        { folderPath },
      );
      const deletedCount = result.records[0].get("deletedCount").toNumber();
      logger.debug(
        `Deleted ${deletedCount} files from folder ${folderPath} in Neo4j`,
      );
      return deletedCount;
    } catch (error) {
      logger.error(
        `Neo4jRepoFileRepository: Error deleting folder contents: ${error.message}`,
      );
      throw error;
    } finally {
      await session.close();
    }
  }
}

export default Neo4jRepoFileRepository;

<<< END ./server/repositories/Neo4jRepoFileRepository.js >>>

--- FILE: ./server/repositories/Neo4jRepository.js ---

<<< BEGIN ./server/repositories/Neo4jRepository.js >>>
// File: ./server/repositories/Neo4jRepository.js

import driver from '../config/neo4jConfig.js';
import logger from '../../shared/logger.js';

class Neo4jRepository {

  static async getNodeAndRelationshipTypes() {
    const session = driver.session();
    try {
      logger.debug('Executing Neo4j query for node and relationship types');

      const result = await session.run(`
        CALL {
          MATCH (n)
          RETURN labels(n) AS label, count(n) AS count, false AS isRelationship
        UNION ALL
          MATCH ()-[r]->()
          RETURN type(r) AS label, count(r) AS count, true AS isRelationship
        }
        RETURN label, count, isRelationship
        ORDER BY count DESC
        LIMIT 20
      `);

      const types = result.records.map(record => ({
        name: Array.isArray(record.get('label')) ? record.get('label')[0] : record.get('label'),
        count: record.get('count'), 
        isRelationship: record.get('isRelationship')
      }));
      
      logger.debug(`Retrieved ${types.length} node and relationship types`);
      return types;
    } catch (error) {
      logger.error(`Error in getNodeAndRelationshipTypes: ${error.message}`);
      throw error;
    } finally {
      await session.close();
    }
  }

  static async getFilteredResults(filters) {
    const session = driver.session();
    try {
      const nodeFilters = filters.filter(f => !f.isRelationship);
      const relFilters = filters.filter(f => f.isRelationship);

      let query = `MATCH (n)`;
      let whereClause = [];

      if (nodeFilters.length > 0) {
        whereClause.push(nodeFilters.map(f => `n:${f.name}`).join(' OR '));
      }

      if (relFilters.length > 0) {
        query += `-[r]->()`;
        whereClause.push(relFilters.map(f => `type(r) = '${f.name}'`).join(' OR '));
      }

      if (whereClause.length > 0) {
        query += ` WHERE ${whereClause.join(' AND ')}`;
      }

      query += `
        RETURN 
          CASE 
            WHEN n.name IS NOT NULL THEN n.name 
            WHEN type(r) IS NOT NULL THEN type(r)
            ELSE null 
          END AS name,
          CASE
            WHEN n IS NOT NULL THEN labels(n)[0]
            WHEN r IS NOT NULL THEN 'relationship'
            ELSE null
          END AS type
        LIMIT 30
      `;

      logger.debug(`Executing Neo4j query: ${query}`);
      const result = await session.run(query);

      return result.records.map(record => ({
        name: record.get('name'),
        type: record.get('type')
      }));
    } catch (error) {
      logger.error(`Error in getFilteredResults: ${error.message}`);
      throw error;
    } finally {
      await session.close();
    }
  }


  static async getUpdatedFilterCounts(selectedFilters) {
    const session = driver.session();
    try {
      const query = `
        MATCH (n)
        OPTIONAL MATCH (n)-[r]->()
        WITH labels(n) AS nodeLabels, type(r) AS relType
        UNWIND nodeLabels + [relType] AS label
        WITH label
        WHERE label IS NOT NULL
        RETURN 
          label AS name,
          COUNT(*) AS count,
          CASE WHEN label IN $relTypes THEN true ELSE false END AS isRelationship
      `;

      const relTypes = selectedFilters.filter(f => f.isRelationship).map(f => f.name);
      const result = await session.run(query, { relTypes });

      return result.records.map(record => ({
        name: record.get('name'),
        count: record.get('count').toNumber(),
        isRelationship: record.get('isRelationship')
      }));
    } catch (error) {
      logger.error(`Error in getUpdatedFilterCounts: ${error.message}`);
      throw error;
    } finally {
      await session.close();
    }
  }

  static async getTags() {
    const session = driver.session();
    try {
      logger.debug('Executing Neo4j query for TopicTags and Tags');

      const result = await session.run(`
        MATCH (t:TopicTag)
        RETURN 'TopicTag' AS tagType, t.name AS name
        UNION ALL
        MATCH (t:Tag)
        RETURN 'Tag' AS tagType, t.name AS name
        ORDER BY name
      `);

      const tags = result.records.map(record => ({
        tagType: record.get('tagType'),
        name: record.get('name')
      }));

      logger.debug(`Retrieved ${tags.length} tags`);
      return tags;
    } catch (error) {
      logger.error(`Error in getTags: ${error.message}`);
      throw error;
    } finally {
      await session.close();
    }
  }

  static convertCypherDateToJsDate(cypherDate) {
    const {
      year,
      month,
      day,
      hour,
      minute,
      second,
      nanosecond,
      timeZoneOffsetSeconds
    } = cypherDate;

    const jsDate = new Date(Date.UTC(
      Number(year),
      Number(month) - 1, 
      Number(day),
      Number(hour),
      Number(minute),
      Number(second),
      Number(nanosecond) / 1e6 // Convert nanoseconds to milliseconds
    ));

    jsDate.setTime(jsDate.getTime() - Number(timeZoneOffsetSeconds) * 1000);

    return jsDate;
  }
}

export default Neo4jRepository;
<<< END ./server/repositories/Neo4jRepository.js >>>

--- FILE: ./server/routes/index.js ---

<<< BEGIN ./server/routes/index.js >>>
// File: server/routes/index.js

import express from "express";
import FactController from "../controllers/FactController.js";
import DocumentationController from "../controllers/DocumentationController.js";
import RepositoryController from "../controllers/RepositoryController.js";
import DocBuilderController from "../controllers/DocBuilderController.js";
import SchemaController from "../controllers/SchemaController.js";
import DocumentController from "../controllers/DocumentController.js";
import ApiCallController from "../controllers/ApiCallController.js";
import DatabaseUtilityController from "../controllers/DatabaseUtilityController.js";

const router = express.Router();

// API call records route
router.get("/api-calls", ApiCallController.getApiCalls);

// Database Utility routes (updated)
router.get("/database-utility/filters", DatabaseUtilityController.getFilterBubbles);
router.post("/database-utility/apply-filters", DatabaseUtilityController.applyFilters);
router.get("/database-utility/tags", DatabaseUtilityController.getTags); 

// Fact routes
router.get("/facts", FactController.getFacts);
router.post("/facts", FactController.processFacts);
router.post("/facts/finalize", FactController.finalizeReviewedFacts);

// Claude API routes
router.post("/claude/extract-facts", FactController.extractFacts);
router.post("/claude/reconcile-facts", FactController.reconcileFacts);
router.post("/claude/organize-facts", FactController.organizeFacts);

// Repository routes
router.get("/repository/files", RepositoryController.getRepositoryFiles);
router.post("/repository/file/refresh", RepositoryController.refreshFile);
router.post("/repository/file/delete", RepositoryController.deleteFile);
router.post("/repository/folder/refresh", RepositoryController.refreshFolder);
router.post("/repository/folder/delete", RepositoryController.deleteFolder);
router.get("/repository/file/mermaid/:filePath", RepositoryController.generateMermaidDiagram);
router.get("/repository/file/:filePath", RepositoryController.getFileDetails);

// Documentation routes
router.get("/documentation", DocumentationController.getDocumentation);
router.post("/documentation/refresh", DocumentationController.refreshDocumentation);

// Document routes
router.get("/documents", DocumentController.getDocuments);
router.get("/documents/:id", DocumentController.getDocument);
router.put("/documents/:id", DocumentController.updateDocument);
router.post("/documents", DocumentController.createDocument);
router.delete("/documents/:id", DocumentController.deleteDocument);


// DocBuilder routes
router.get("/documents", DocBuilderController.getDocument);
router.post("/documents/section", DocBuilderController.updateSection);

// Schema route
router.get("/schema", SchemaController.getSchema);


export default router;
<<< END ./server/routes/index.js >>>

--- FILE: ./server/server.js ---

<<< BEGIN ./server/server.js >>>
import express from "express";
import cors from "cors";
import dotenv from "dotenv";
import path from "path";
import { fileURLToPath } from "url";
import apiRoutes from "./routes/index.js";
import errorHandler from "./middleware/errorHandler.js";
import logger from "../shared/logger.js";

dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const port = process.env.PORT || 3001;

app.use(cors());
app.use(express.json());

// Logging middleware
app.use((req, res, next) => {
  logger.info(`${req.method} ${req.url}`);
  res.on("finish", () => {
    logger.info(`${req.method} ${req.url} ${res.statusCode}`);
  });
  next();
});

// Use the unified routes
app.use("/api", apiRoutes);

// Serve static files from the React app in both production and development
const clientBuildPath = path.join(__dirname, "..", "client", "dist");
app.use(express.static(clientBuildPath));

// The "catchall" handler: for any request that doesn't
// match one above, send back React's index.html file.
app.get('*', (req, res) => {
  res.sendFile(path.join(clientBuildPath, 'index.html'));
});

// Error handling middleware
app.use(errorHandler);

app.listen(port, "0.0.0.0", () => {
  logger.success(`Server running on port ${port}`);
});
<<< END ./server/server.js >>>

--- FILE: ./server/services/DocumentationService.js ---

<<< BEGIN ./server/services/DocumentationService.js >>>
import Neo4jDocumentationRepository from "../repositories/Neo4jDocumentationRepository.js";
import Neo4jRepoFileRepository from "../repositories/Neo4jRepoFileRepository.js";
import { callClaude } from "./ClaudeApiClient.js";
import { generateDocumentationPrompt } from "../prompts/generateDocumentation.js";
import logger from "../../shared/logger.js";

class DocumentationService {
  static async getDocumentation() {
    try {
      return await Neo4jDocumentationRepository.getDocumentation();
    } catch (error) {
      logger.error(
        `Error in DocumentationService.getDocumentation: ${error.message}`,
      );
      throw error;
    }
  }

  static async refreshDocumentation() {
    try {
      // Change this line to use the correct method
      const files = await Neo4jRepoFileRepository.getAllFiles();
      const fileList = files
        .map(
          (file) =>
            `${file.file_path}: ${file.file_content.substring(0, 100)}...`,
        )
        .join("\n");

      const prompt = generateDocumentationPrompt.replace(
        "{fileList}",
        fileList,
      );
      const documentation = await callClaude(prompt);

      await Neo4jDocumentationRepository.saveDocumentation(documentation);
      return "Documentation refreshed successfully";
    } catch (error) {
      logger.error(
        `Error in DocumentationService.refreshDocumentation: ${error.message}`,
      );
      throw error;
    }
  }
}

export default DocumentationService;

<<< END ./server/services/DocumentationService.js >>>

--- FILE: ./server/services/FactService.js ---

<<< BEGIN ./server/services/FactService.js >>>
import { callClaude } from "./ClaudeApiClient.js";
import Neo4jFactRepository from "../repositories/Neo4jFactRepository.js";
import { extractFactsPrompt } from "../prompts/extractFacts.js";
import { reconcileFactsPrompt } from "../prompts/reconcileFacts.js";
import { organizeFactsPrompt } from "../prompts/organizeFacts.js";
import logger from "../../shared/logger.js";

class FactService {
  static async processFacts(input) {
    try {
      logger.info("Starting fact processing");

      if (input.trim().toLowerCase() === "delete") {
        logger.info("Delete command received. Clearing all facts.");
        return {
          sustained: [],
          new: [],
          conflicts: [
            {
              id: "d1",
              newFact: "No facts",
              oldFact: "All previous facts",
              explanation: "User requested to delete all facts",
            },
          ],
        };
      }

      // Extract facts
      const extractPrompt = extractFactsPrompt.replace("{input}", input);
      const extractedFacts = await callClaude(extractPrompt);
      logger.debug(`Extracted facts: ${extractedFacts.substring(0, 100)}...`);

      // Get current facts
      const currentFacts = await this.getFacts();

      // Reconcile facts
      const reconcilePrompt = reconcileFactsPrompt
        .replace("{previousFacts}", currentFacts)
        .replace("{newFacts}", extractedFacts);
      const reconcileResponse = await callClaude(reconcilePrompt);
      const reconcileResult = JSON.parse(reconcileResponse);
      logger.debug(
        `Reconciled facts: ${JSON.stringify(reconcileResult).substring(0, 100)}...`,
      );

      return reconcileResult;
    } catch (error) {
      logger.error(`Error in processFacts: ${error.message}`);
      throw error;
    }
  }

  static async finalizeFactsAndSave(reviewedFacts) {
    try {
      logger.info("Finalizing and saving facts");

      // Merge sustained, new, and accepted conflict facts
      const allFacts = [
        ...reviewedFacts.sustained.map((f) => f.fact),
        ...reviewedFacts.new.filter((f) => f.accepted).map((f) => f.fact),
        ...reviewedFacts.conflicts
          .filter((f) => f.accepted)
          .map((f) => f.newFact),
      ];

      // Organize facts
      const organizePrompt = organizeFactsPrompt.replace(
        "{facts}",
        allFacts.join("\n"),
      );
      const organizedFacts = await callClaude(organizePrompt);
      logger.debug(`Organized facts: ${organizedFacts.substring(0, 100)}...`);

      // Save organized facts
      await this.saveFacts(organizedFacts);

      logger.info("Facts finalized and saved successfully");
      return organizedFacts;
    } catch (error) {
      logger.error(`Error in finalizeFactsAndSave: ${error.message}`);
      throw error;
    }
  }

  static async getFacts() {
    try {
      const facts = await Neo4jFactRepository.getData();
      return facts.value || "";
    } catch (error) {
      logger.error(`Error in getFacts: ${error.message}`);
      throw error;
    }
  }

  static async saveFacts(facts) {
    try {
      await Neo4jFactRepository.saveData(facts);
      logger.success("Facts saved successfully");
    } catch (error) {
      logger.error(`Error in saveFacts: ${error.message}`);
      throw error;
    }
  }
}

export default FactService;

<<< END ./server/services/FactService.js >>>

--- FILE: ./server/services/FilePathFilter.js ---

<<< BEGIN ./server/services/FilePathFilter.js >>>
// File: ./server/services/FilePathFilter.js

import { includePatterns, excludePatterns } from "../../shared/filePathConfig.js";
import path from 'path';
import logger from "../../shared/logger.js";

function matchPattern(filePath, pattern) {
    if (pattern.endsWith('/*')) {
        const dirPart = pattern.slice(0, -2);
        return filePath === dirPart || filePath.startsWith(dirPart + '/');
    } else {
        return filePath === pattern;
    }
}

export function shouldProcess(filePath, isDirectory) {
    const normalizedPath = './' + filePath.replace(/\\/g, '/');
    // logger.debug(`Processing path: ${normalizedPath}, isDirectory: ${isDirectory}`);

    // Check if the file/directory should be excluded first
    for (const pattern of excludePatterns) {
        if (matchPattern(normalizedPath, pattern)) {
            // logger.debug(`Excluded by pattern: ${pattern}`);
            return false;
        }
    }

    // Check if the file/directory should be included
    for (const pattern of includePatterns) {
        if (matchPattern(normalizedPath, pattern)) {
            // logger.debug(`Included by pattern: ${pattern}`);
            return true;
        }
    }

    // logger.debug(`Not included by any pattern: ${normalizedPath}`);
    return false;
}
<<< END ./server/services/FilePathFilter.js >>>

--- FILE: ./server/services/FileStatusChecker.js ---

<<< BEGIN ./server/services/FileStatusChecker.js >>>
// File: ./server/services/FileStatusChecker.js

class FileStatusChecker {
  getFileStatus(stats, dbFile) {
    if (!dbFile) return "new";
    if (new Date(stats.mtime) > new Date(dbFile.modified_at)) return "modified";
    return "unchanged";
  }
}

export default FileStatusChecker;
<<< END ./server/services/FileStatusChecker.js >>>

--- FILE: ./server/services/LLMService.js ---

<<< BEGIN ./server/services/LLMService.js >>>
// File: ./server/services/LLMService.js

import { callClaude } from "./ClaudeApiClient.js";
import logger from "../../shared/logger.js";

class LLMService {
  static async generateDocumentation(fileContent) {
    try {
      const prompt =
        "Generate 3 sentences of concise documentation for this file, covering: 1) how it handles core functionality, 2) the operation it performs, and 3) its typical usage in context or purpose.";
      const fullPrompt = `${prompt}\n\nFile content:\n${fileContent}`;

      logger.info("Generating documentation using LLM");
      const documentation = await callClaude(fullPrompt);

      logger.success("Documentation generated successfully");
      return documentation.trim();
    } catch (error) {
      logger.error(`Error generating documentation: ${error.message}`);
      return "Failed to generate documentation";
    }
  }

  static async generateMermaidDiagram(fileContent, fileType) {
    try {
      const prompt = await import("../prompts/generateMermaidDiagram.js");
      const fullPrompt = prompt.default
        .replace("{fileContent}", fileContent)
        .replace("{fileType}", fileType);

      logger.info("Generating Mermaid diagram using LLM");
      const rawMermaidCode = await callClaude(fullPrompt);
      logger.debug(
        `Received raw Mermaid code: ${rawMermaidCode.substring(0, 100)}...`,
      );

      // Process the raw Mermaid code
      const cleanedMermaidCode = this.cleanMermaidCode(rawMermaidCode);

      logger.debug(
        `Cleaned Mermaid code: ${cleanedMermaidCode.substring(0, 100)}...`,
      );
      logger.success("Mermaid diagram generated successfully");
      return cleanedMermaidCode.trim();
    } catch (error) {
      logger.error(`Error generating Mermaid diagram: ${error.message}`);
      logger.error(`Error stack: ${error.stack}`);
      return "Failed to generate Mermaid diagram";
    }
  }

  static cleanMermaidCode(rawCode) {
    // Remove any leading "```mermaid" and trailing "```"
    let cleanedCode = rawCode.replace(/^```mermaid\n?/, "").replace(/```$/, "");

    // Ensure the code starts with a valid Mermaid diagram type
    const validStartKeywords = [
      "graph",
      "flowchart",
      "sequenceDiagram",
      "classDiagram",
      "stateDiagram",
      "erDiagram",
      "gantt",
      "pie",
      "gitGraph",
    ];
    const startsWithValidKeyword = validStartKeywords.some((keyword) =>
      cleanedCode.trim().startsWith(keyword),
    );

    if (!startsWithValidKeyword) {
      logger.warn("Mermaid code does not start with a valid diagram type");
      return "Failed to generate valid Mermaid diagram";
    }

    return cleanedCode.trim();
  }
}

export default LLMService;

<<< END ./server/services/LLMService.js >>>

--- FILE: ./server/services/fileUtils.js ---

<<< BEGIN ./server/services/fileUtils.js >>>
import path from "path";
import logger from "../logger.js";

export function shouldProcessDirectory(dirPath, excludedDirs, includeDir) {
  // Always process the include directory and its subdirectories
  if (dirPath.startsWith(includeDir)) {
    logger.debug(
      `Should process directory ${dirPath}: true (included directory)`,
    );
    return true;
  }

  const shouldProcess = !excludedDirs.some((pattern) =>
    matchesPattern(dirPath, pattern),
  );
  logger.debug(`Should process directory ${dirPath}: ${shouldProcess}`);
  return shouldProcess;
}

export function shouldProcessFile(filePath, excludedDirs, includeDir) {
  // Always process files in the include directory and its subdirectories
  if (filePath.startsWith(includeDir)) {
    logger.debug(`Should process file ${filePath}: true (included directory)`);
    return true;
  }

  const shouldProcess = !excludedDirs.some((pattern) =>
    matchesPattern(filePath, pattern),
  );
  logger.debug(`Should process file ${filePath}: ${shouldProcess}`);
  return shouldProcess;
}

export function matchesPattern(filePath, pattern) {
  const regex = new RegExp("^" + pattern.replace(/\*/g, ".*") + "$");
  return regex.test(filePath);
}

<<< END ./server/services/fileUtils.js >>>

--- FILE: ./server/services/RepoFileService.js ---

<<< BEGIN ./server/services/RepoFileService.js >>>
// File: ./server/services/RepoFileService.js
import path from "path";
import fs from "fs/promises";
import Neo4jRepoFileRepository from "../repositories/Neo4jRepoFileRepository.js";
import LLMService from "./LLMService.js";
import logger from "../../shared/logger.js";
import { shouldProcess } from "./FilePathFilter.js";

class RepoFileService {
  static async getRepositoryFiles(limit,page,repoPath = process.cwd()) {
    try {
      logger.debug("Getting repository files");
      let fileTree = {
        id: "root",
        name: path.basename(repoPath),
        type: "directory",
        children: [],
      };

      const skip =  (page -1 ) * limit;
      const dbFiles = await Neo4jRepoFileRepository.getAllFiles(limit,skip);
      logger.debug(`Retrieved ${dbFiles.length} files from the database`);

      const dbFilesMap = new Map(
        dbFiles
          .filter((file) => file && file.file_path)
          .map((file) => [file.file_path, file])
      );

      logger.debug(`Filtered ${dbFilesMap.size} valid files`);

      await this.buildDirectoryTree(repoPath, "", fileTree, dbFilesMap);

      // Add remaining files from the database that weren't found in the filesystem
      for (const [filePath, dbFile] of dbFilesMap) {
        this.addFileToTree(fileTree, filePath, {
          id: filePath,
          name: path.basename(filePath),
          type: "file",
          size: dbFile.file_size,
          modifiedAt: dbFile.modified_at,
          status: "deleted",
          hasMermaidDiagram: !!dbFile.mermaid_diagram,
        });
      }

      logger.success("Retrieved and compared repository files");
      return { fileTree };
    } catch (error) {
      logger.error(`Error in RepoFileService.getRepositoryFiles: ${error.message}`);
      throw error;
    }
  }
  
  static async buildDirectoryTree(dirPath, relativePath, tree, dbFilesMap) {
    try {
      const entries = await fs.readdir(dirPath, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = path.join(dirPath, entry.name);
        const entryRelativePath = path.join(relativePath, entry.name);

        if (!shouldProcess(entryRelativePath, entry.isDirectory())) continue;

        if (entry.isDirectory()) {
          const newDir = {
            id: entryRelativePath || "root",
            name: entry.name,
            type: "directory",
            children: [],
          };
          tree.children.push(newDir);
          await this.buildDirectoryTree(fullPath, entryRelativePath, newDir, dbFilesMap);
        } else {
          const stats = await fs.stat(fullPath);
          const dbFile = dbFilesMap.get(entryRelativePath);
          const status = this.getFileStatus(stats, dbFile);
          dbFilesMap.delete(entryRelativePath);

          tree.children.push({
            id: entryRelativePath,
            name: entry.name,
            type: "file",
            size: stats.size,
            modifiedAt: stats.mtime.toISOString(),
            status: status,
            hasMermaidDiagram: status !== "new" && !!dbFile?.mermaid_diagram,
          });
        }
      }
    } catch (error) {
      logger.error(`Error reading directory ${dirPath}: ${error.message}`);
    }
  }

  static addFileToTree(tree, filePath, fileInfo) {
    const parts = filePath.split(path.sep);
    let currentNode = tree;

    for (let i = 0; i < parts.length - 1; i++) {
      const part = parts[i];
      let childNode = currentNode.children.find((child) => child.name === part);
      if (!childNode) {
        childNode = {
          id: parts.slice(0, i + 1).join(path.sep),
          name: part,
          type: "directory",
          children: [],
        };
        currentNode.children.push(childNode);
      }
      currentNode = childNode;
    }

    currentNode.children.push(fileInfo);
  }

  static getFileStatus(stats, dbFile) {
    if (!dbFile) return "new";
    if (new Date(stats.mtime) > new Date(dbFile.modified_at)) return "modified";
    return "unchanged";
  }

  static async refreshFile(filePath) {
    if (!filePath) {
      throw new Error('File path is required');
    }
    try {
      logger.debug(`Starting refreshFile for: ${filePath}`);
      const fullPath = path.join(process.cwd(), filePath);
      const fileContent = await fs.readFile(fullPath, "utf-8");
      const stats = await fs.stat(fullPath);
      const fileType = path.extname(filePath).slice(1);

      const documentation = await LLMService.generateDocumentation(fileContent);
      const mermaidDiagram = await LLMService.generateMermaidDiagram(fileContent, fileType);

      const fileData = {
        file_name: path.basename(filePath),
        file_path: filePath,
        file_content: fileContent,
        file_size: stats.size,
        modified_at: stats.mtime.toISOString(),
        documentation: documentation,
        mermaid_diagram: mermaidDiagram,
      };

      await Neo4jRepoFileRepository.saveFile(fileData);
      logger.success(`File ${filePath} refreshed, documented, and diagrammed successfully`);

      return {
        status: "success",
        message: `File ${filePath} refreshed, documented, and diagrammed successfully`,
        hasMermaidDiagram: !!mermaidDiagram,
      };
    } catch (error) {
      logger.error(`Error refreshing file ${filePath}: ${error.message}`);
      throw error;
    }
  }

  static async deleteFile(filePath) {
    if (!filePath) {
      throw new Error('File path is required');
    }
    try {
      await Neo4jRepoFileRepository.deleteFile(filePath);
      logger.success(`File ${filePath} deleted from database`);
      return {
        status: "success",
        message: `File ${filePath} deleted from database`,
      };
    } catch (error) {
      logger.error(`Error deleting file ${filePath} from database: ${error.message}`);
      throw error;
    }
  }

  static async refreshFolder(folderPath) {
    if (!folderPath) {
      throw new Error('Folder path is required');
    }
    try {
      const updatedFiles = await this.refreshFolderRecursive(folderPath);
      logger.success(`Folder ${folderPath} refreshed successfully`);
      return { status: "success", updatedFiles };
    } catch (error) {
      logger.error(`Error refreshing folder ${folderPath}: ${error.message}`);
      throw error;
    }
  }

  static async deleteFolder(folderPath) {
    if (!folderPath) {
      throw new Error('Folder path is required');
    }
    try {
      const deletedFiles = await Neo4jRepoFileRepository.deleteFolderContents(folderPath);
      logger.success(`Folder ${folderPath} deleted from database`);
      return {
        status: "success",
        message: `Folder ${folderPath} deleted from database`,
        deletedFiles,
      };
    } catch (error) {
      logger.error(`Error deleting folder ${folderPath} from database: ${error.message}`);
      throw error;
    }
  }

  static async getFilesInFolder(folderPath) {
    const files = [];
    await this.traverseFolder(folderPath, files, process.cwd());
    return files.map(f => f.path);
  }

  static async refreshFileIfNeeded(fullPath, relativePath) {
    const stats = await fs.stat(fullPath);
    const dbFile = await Neo4jRepoFileRepository.getFile(relativePath);

    if (!dbFile || new Date(stats.mtime) > new Date(dbFile.modified_at)) {
      const fileContent = await fs.readFile(fullPath, "utf-8");
      const fileType = path.extname(fullPath).slice(1);

      const documentation = await LLMService.generateDocumentation(fileContent);
      const mermaidDiagram = await LLMService.generateMermaidDiagram(fileContent, fileType);

      const fileData = {
        file_name: path.basename(fullPath),
        file_path: relativePath,
        file_content: fileContent,
        file_size: stats.size,
        modified_at: stats.mtime.toISOString(),
        documentation: documentation,
        mermaid_diagram: mermaidDiagram,
      };

      await Neo4jRepoFileRepository.saveFile(fileData);
      logger.info(`File ${relativePath} updated`);

      return {
        path: relativePath,
        status: dbFile ? 'updated' : 'new',
        hasMermaidDiagram: !!mermaidDiagram,
      };
    }

    return null;
  }

  static async refreshFolderRecursive(folderPath, rootDir = process.cwd()) {
    const updatedFiles = [];
    const entries = await fs.readdir(folderPath, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(folderPath, entry.name);
      const relativePath = path.relative(rootDir, fullPath);

      if (!shouldProcess(relativePath, entry.isDirectory())) continue;

      if (entry.isDirectory()) {
        const subFolderUpdates = await this.refreshFolderRecursive(fullPath, rootDir);
        updatedFiles.push(...subFolderUpdates);
      } else {
        const fileUpdate = await this.refreshFileIfNeeded(fullPath, relativePath);
        if (fileUpdate) {
          updatedFiles.push(fileUpdate);
        }
      }
    }

    return updatedFiles;
  }
  
  static async traverseFolder(folderPath, files, rootDir) {
    const entries = await fs.readdir(folderPath, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(folderPath, entry.name);
      const relativePath = path.relative(rootDir, fullPath);

      if (shouldProcess(relativePath, entry.isDirectory())) {
        if (entry.isDirectory()) {
          await this.traverseFolder(fullPath, files, rootDir);
        } else {
          const stats = await fs.stat(fullPath);
          files.push({
            path: relativePath,
            name: entry.name,
            size: stats.size,
            modifiedAt: stats.mtime.toISOString(),
          });
        }
      }
    }
  }
}

export default RepoFileService;
<<< END ./server/services/RepoFileService.js >>>

--- FILE: ./server/services/ArtifactChain.js ---

<<< BEGIN ./server/services/ArtifactChain.js >>>
import driver from "../config/neo4jConfig.js";
import logger from "../../shared/logger.js";
import {
    documentCreationPrompt,
    saveDocumentCypher,
    updateDocumentCypher,
} from "../prompts/documentCreationPrompts.js";
import { callClaude } from "./ClaudeApiClient.js";

async function generateCypher(tags) {
    if (!tags || tags.length === 0) {
        return { query: "MATCH (n:RepoFile) RETURN n LIMIT 100", params: {} };
    }

    const tagNames = tags.map((_, index) => `$tagName${index}`).join(", ");

    const query = `
    MATCH (tag)
    WHERE (tag:TopicTag OR tag:Tag) AND tag.name IN [${tagNames}]
    MATCH (n)-[:ASSOCIATED_WITH]-(tag)
    RETURN DISTINCT n
    LIMIT 100
    `;

    const params = tags.reduce((acc, tag, index) => {
        acc[`tagName${index}`] = tag.name;
        return acc;
    }, {});

    return { query, params };
}

async function getResults(cypher) {
    const session = driver.session();
    const { query, params } = cypher;
    try {
        const result = await session.run(query, params);
        return result.records.map((record) => record.get("n").properties);
    } catch (error) {
        logger.error(`Error executing Cypher query: ${error.message}`);
        throw error;
    } finally {
        await session.close();
    }
}

async function createDocument(prompt, context) {
    try {
        const serializedPrompt = documentCreationPrompt
            .replace("{prompt}", prompt)
            .replace("{context}", JSON.stringify(context));
        const response = await callClaude(serializedPrompt);
        return response;
    } catch (error) {
        logger.error(`Error creating document: ${error.message}`);
        throw error;
    }
}

async function saveDocument(document, contextFilePaths) {
    const session = driver.session();
    try {
        const result = await session.run(saveDocumentCypher, {
            document,
            contextFilePaths,
        });
        return result.records[0].get("documentId");
    } finally {
        await session.close();
    }
}

async function updateDocument(id, newDocument, contextFilePaths) {
    const session = driver.session();
    try {
        const result = await session.run(updateDocumentCypher, {
            id,
            newDocument,
            contextFilePaths,
        });
        return result.records[0].get("documentId");
    } finally {
        await session.close();
    }
}

async function getLatestDocumentVersion(id) {
    const session = driver.session();
    try {
        const result = await session.run(
            `MATCH (d:Document {id: $id})
             RETURN d.version AS version`,
            { id },
        );
        return result.records[0]?.get("version") || 0;
    } finally {
        await session.close();
    }
}
export async function createArtifactCreationChain() {
    return async (input) => {
        console.log(`\n>>>>>> QUERY\n`, input, `\n>>>>>\n`);
        let promptTags = [];

        // Step 1: Parse and validate tags
        try {
            if (input.tags) {
                if (typeof input.tags === 'string') {
                    promptTags = JSON.parse(input.tags);
                } else if (Array.isArray(input.tags)) {
                    promptTags = input.tags;
                }
            }
        } catch (error) {
            console.error("Error parsing tags:", error);
            // If parsing fails, continue with empty tags
        }

        // Ensure promptTags is always an array
        promptTags = Array.isArray(promptTags) ? promptTags : [];

        // Step 2: Generate Cypher to fetch relevant files and documents
        const cypher = await generateCypher(promptTags);
        console.log(`\n>>>>>> GENERATED CYPHER\n`, cypher, `\n>>>>>\n`);

        // Step 3: Use the Cypher to get context from the graph
        const context = await getResults(cypher);

        // Step 4: Create the document using the context and schema
        const documentation = await createDocument(input.prompt, context);

        // Step 5: Prepare the document node
        const now = new Date().toISOString();
        let version = 1;
        let isUpdate = false;

        if (input.id) {
            isUpdate = true;
            version = (await getLatestDocumentVersion(input.id)) + 1;
        }

        const documentNode = {
            id: input.id || crypto.randomUUID(),
            title: input.title || `Generated Document ${now}`,
            prompt: input.prompt,
            createdAt: now,
            updatedAt: now,
            documentation: documentation,
            version: version,
            tags: JSON.stringify(promptTags),  // Use the parsed and validated tags
        };

        // Step 6: Save the document and link it with context nodes
        const contextFilePaths = context.map((node) => node.file_path);
        let documentId;

        if (isUpdate) {
            documentId = await updateDocument(
                input.id,
                documentNode,
                contextFilePaths,
            );
            console.log(
                `\n>>>>>> UPDATED DOCUMENT\n`,
                documentNode,
                `\n>>>>>\n`,
            );
        } else {
            documentId = await saveDocument(documentNode, contextFilePaths);
            console.log(
                `\n>>>>>> SAVED NEW DOCUMENT\n`,
                documentNode,
                `\n>>>>>\n`,
            );
        }

        return {
            documentId,
            document: documentNode,
            isUpdate,
        };
    };
}

export default createArtifactCreationChain;

<<< END ./server/services/ArtifactChain.js >>>

--- FILE: ./server/services/ClaudeApiClient.js ---

<<< BEGIN ./server/services/ClaudeApiClient.js >>>
// File: ./server/services/ClaudeApiClient.js

import Anthropic from "@anthropic-ai/sdk";
import logger from "../../shared/logger.js";
import Neo4jApiCallRepository from "../repositories/Neo4jApiCallRepository.js";

const anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });

export async function callClaude(prompt, model = "claude-3-5-sonnet-20240620" ) {
  try {
    logger.info(`Calling Claude API with model: ${model}`);

    const response = await anthropic.messages.create({
      model: model,
      max_tokens: 4096,
      temperature: 0,
      messages: [{ role: "user", content: prompt }],
    });

    if (!response || !response.content || !response.content[0]) {
      throw new Error("Malformed response from Claude API");
    }

    const result = response.content[0].text;

    // Record API call
    await Neo4jApiCallRepository.saveApiCall({
      timestamp: new Date(),
      inputTokens: response.usage.input_tokens,
      outputTokens: response.usage.output_tokens,
      message: prompt.substring(0, 200), // Truncate to 200 characters
    });

    logger.success("Claude API call successful");
    return result;
  } catch (error) {
    logger.error(`Error calling Claude API: ${error.message}`);
    throw error;
  }
}
<<< END ./server/services/ClaudeApiClient.js >>>

--- FILE: ./server/services/DatabaseUtilityService.js ---

<<< BEGIN ./server/services/DatabaseUtilityService.js >>>
// File: ./server/services/DatabaseUtilityService.js

import Neo4jRepository from '../repositories/Neo4jRepository.js';
import logger from '../../shared/logger.js';

class DatabaseUtilityService {
  static async getFilterBubbles() {
    try {
      logger.debug('DatabaseUtilityService: Fetching top 20 node and relationship types');

      const types = await Neo4jRepository.getNodeAndRelationshipTypes();
      logger.debug(`Retrieved ${types.length} types`);
      return types.slice(0, 20).map(type => ({
        name: type.name,
        count: typeof type.count === 'object' && type.count.toNumber ? type.count.toNumber() : type.count,
        isRelationship: type.isRelationship
      }));
    } catch (error) {
      logger.error(`Error in getFilterBubbles: ${error.message}`);
      throw error;
    }
  }

  static async applyFilters(filters) {
    try {
      logger.debug(`Applying filters: ${JSON.stringify(filters)}`);
      const results = await Neo4jRepository.getFilteredResults(filters);
      logger.debug(`Retrieved ${results.length} results after applying filters`);

      return results.map(result => ({
        name: result.name,
        type: result.type
      }));
    } catch (error) {
      logger.error(`Error in applyFilters: ${error.message}`);
      throw error;
    }
  }

  static async getUpdatedFilterCounts(selectedFilters) {
    try {
      logger.debug(`Getting updated filter counts for: ${JSON.stringify(selectedFilters)}`);
      const updatedCounts = await Neo4jRepository.getUpdatedFilterCounts(selectedFilters);
      logger.debug(`Retrieved updated counts for ${updatedCounts.length} filters`);
      return updatedCounts;
    } catch (error) {
      logger.error(`Error in getUpdatedFilterCounts: ${error.message}`);
      throw error;
    }
  }

 static async getTags() {
    try {
      logger.debug('DatabaseUtilityService: Fetching all tags');
      const tags = await Neo4jRepository.getTags();
      return tags; 
    } catch (error) {
      logger.error(`Error in getTags: ${error.message}`);
      throw error;
    }
  }
}

export default DatabaseUtilityService;
<<< END ./server/services/DatabaseUtilityService.js >>>

--- FILE: ./client/index.html ---

<<< BEGIN ./client/index.html >>>
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AIM Facts</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/index.jsx"></script>
  </body>
</html>

<<< END ./client/index.html >>>

--- FILE: ./client/src/components/DatabaseSchema/DatabaseSchema.jsx ---

<<< BEGIN ./client/src/components/DatabaseSchema/DatabaseSchema.jsx >>>
import React from 'react';
import SchemaViewer from './SchemaViewer';

const DatabaseSchema = ({ setNotify }) => {
  return <SchemaViewer setNotify={setNotify} />;
};

export default DatabaseSchema;
<<< END ./client/src/components/DatabaseSchema/DatabaseSchema.jsx >>>

--- FILE: ./client/src/components/DatabaseSchema/SchemaViewer.jsx ---

<<< BEGIN ./client/src/components/DatabaseSchema/SchemaViewer.jsx >>>
// File: ./client/src/components/SchemaViewer.jsx
import React, { useState, useEffect } from "react";
import {
  Box,
  Typography,
  Grid,
  Card,
  CardContent,
  CardActionArea,
  Collapse,
  List,
  ListItem,
  ListItemText,
  Chip,
  styled,
} from "@mui/material";
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import ExpandLessIcon from '@mui/icons-material/ExpandLess';
import axios from "axios";

const CountChip = styled(Chip)(({ theme }) => ({
  position: 'absolute',
  top: 8,
  right: 8,
  backgroundColor: theme.palette.grey[300],
  color: theme.palette.text.secondary,
}));

const SchemaViewer = ({ setNotify }) => {
  const [schema, setSchema] = useState(null);
  const [error, setError] = useState(null);
  const [expandedCards, setExpandedCards] = useState({});

  useEffect(() => {
    fetchSchema();
  }, []);

  const fetchSchema = async () => {
    try {
      const response = await axios.get("/api/schema");
      setSchema(processSchema(response.data));
      setError(null);
    } catch (error) {
      setError("Error fetching schema. Please try again.");
      setNotify("Error fetching schema. Please try again.");
      console.error("Error fetching schema:", error);
    }
  };

  const processSchema = (rawSchema) => {
    const nodes = {};
    const relationships = {};

    rawSchema.nodes.forEach((node) => {
      node.labels.forEach((label) => {
        if (!nodes[label]) {
          nodes[label] = { count: 0, properties: new Set() };
        }
        nodes[label].count++;
        node.properties.forEach((prop) => nodes[label].properties.add(prop));
      });
    });

    rawSchema.relationships.forEach((rel) => {
      if (!relationships[rel.type]) {
        relationships[rel.type] = { count: 0, properties: new Set() };
      }
      relationships[rel.type].count++;
      rel.properties.forEach((prop) => relationships[rel.type].properties.add(prop));
    });

    return { nodes, relationships };
  };

  const toggleCard = (id) => {
    setExpandedCards(prev => ({ ...prev, [id]: !prev[id] }));
  };

  const renderCard = (title, count, properties, id) => (
    <Card sx={{ height: '100%', display: 'flex', flexDirection: 'column', position: 'relative' }}>
      <CardActionArea onClick={() => toggleCard(id)}>
        <CardContent>
          <Typography variant="h6" component="div">
            {title}
          </Typography>
          <CountChip label={count} size="small" />
          {expandedCards[id] ? <ExpandLessIcon /> : <ExpandMoreIcon />}
        </CardContent>
      </CardActionArea>
      <Collapse in={expandedCards[id]} timeout="auto" unmountOnExit>
        <List dense>
          {Array.from(properties).sort().map((prop) => (
            <ListItem key={prop}>
              <ListItemText primary={prop} />
            </ListItem>
          ))}
        </List>
      </Collapse>
    </Card>
  );

  if (error) {
    return <Typography color="error">{error}</Typography>;
  }

  if (!schema) {
    return <Typography>Loading schema...</Typography>;
  }

  // Arrange nodes based on their relevance (this is a simple example, you may need to adjust this logic)
  const arrangedNodes = Object.entries(schema.nodes).sort((a, b) => b[1].count - a[1].count);

  return (
    <Box sx={{ width: "100%", maxWidth: 1200, mx: "auto", mt: 4 }}>
      <Typography variant="h4" gutterBottom>
        Database Schema
      </Typography>

      <Typography variant="h5" gutterBottom sx={{ mt: 4 }}>
        Nodes
      </Typography>
      <Grid container spacing={2}>
        {arrangedNodes.map(([label, info]) => (
          <Grid item xs={12} sm={6} md={4} key={label}>
            {renderCard(label, info.count, info.properties, `node-${label}`)}
          </Grid>
        ))}
      </Grid>

      <Typography variant="h5" gutterBottom sx={{ mt: 4 }}>
        Relationships
      </Typography>
      <Grid container spacing={2}>
        {Object.entries(schema.relationships).map(([type, info]) => (
          <Grid item xs={12} sm={6} md={4} key={type}>
            {renderCard(type, info.count, info.properties, `rel-${type}`)}
          </Grid>
        ))}
      </Grid>
    </Box>
  );
};

export default SchemaViewer;
<<< END ./client/src/components/DatabaseSchema/SchemaViewer.jsx >>>

--- FILE: ./client/src/components/DocBuilder/DocBuilder.jsx ---

<<< BEGIN ./client/src/components/DocBuilder/DocBuilder.jsx >>>
import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import {
  Box,
  TextField,
  Button,
  Typography,
  Card,
  CardContent,
  CircularProgress,
  Modal,
  Chip,
} from "@mui/material";
import axios from "axios";
import DocumentCard from "../_molecules/DocumentCard";

const CONTENT_MAX_WIDTH = 950;

const DocBuilder = ({ setNotify }) => {
  const navigate = useNavigate();
  const [documents, setDocuments] = useState([]);
  const [selectedDocument, setSelectedDocument] = useState(null);
  const [documentContent, setDocumentContent] = useState("");
  const [deletingDocumentId, setDeletingDocumentId] = useState(null);
  const [title, setTitle] = useState("");
  const [prompt, setPrompt] = useState("");
  const [loading, setLoading] = useState(false);
  const [modalOpen, setModalOpen] = useState(false);
  const [tags, setTags] = useState([]);
  const [selectedTags, setSelectedTags] = useState([]);

  useEffect(() => {
    fetchDocuments();
    fetchTags();
  }, []);

  const fetchDocuments = async () => {
    try {
      const response = await axios.get("/api/documents");
      setDocuments(response.data);
    } catch (error) {
      console.error("Error fetching documents:", error);
      setNotify("Error fetching documents");
    }
  };

  const fetchTags = async () => {
    try {
      const response = await axios.get("/api/database-utility/tags");
      console.log("tags",response.data)
      setTags(response.data);
    } catch (error) {
      console.error("Error fetching tags:", error);
      setNotify("Error fetching tags");
    }
  };

  const handleDocumentSelect = async (document) => {
    try {
      const response = await axios.get(`/api/documents/${document.id}`);
      setSelectedDocument(response.data);
      setDocumentContent(response.data.documentation);
      setTitle(response.data.title);
      setPrompt(response.data.prompt || "");
      setSelectedTags(JSON.parse(response.data.tags || "[]"));
    } catch (error) {
      console.error("Error fetching document:", error);
      setNotify("Error fetching document");
    }
  };

  const handleDocumentDelete = async (id) => {
    setDeletingDocumentId(id);
    try {
      await axios.delete(`/api/documents/${id}`);
      setDocuments(documents.filter(doc => doc.id !== id));
      if (selectedDocument && selectedDocument.id === id) {
        setSelectedDocument(null);
        setDocumentContent("");
      }
      setNotify("Document deleted successfully");
    } catch (error) {
      console.error("Error deleting document:", error);
      setNotify("Error deleting document");
    } finally {
      setDeletingDocumentId(null);
    }
  };

  const handleDocumentAdd = async () => {
    setLoading(true);
    try {
      const response = await axios.post("/api/documents", {
        title,
        prompt,
        tags: selectedTags,
      });
      setDocuments([...documents, response.data.document]);
      setTitle("");
      setPrompt("");
      setNotify("Document created successfully");
      setModalOpen(false);
      setSelectedTags([]);
    } catch (error) {
      console.error("Error creating document:", error);
      setNotify("Error creating document");
    } finally {
      setLoading(false);
    }
  };

  const handleDocumentUpdate = async (id, body) => {
    setLoading(true);
    const { title, prompt } = body;
    try {
      const response = await axios.put(`/api/documents/${id}`, {
        title,
        prompt,
        tags: selectedTags,
      });
      const updatedDoc = response.data.document;
      setDocuments(
        documents.map((doc) => (doc.id === updatedDoc.id ? updatedDoc : doc))
      );
      setSelectedDocument(updatedDoc);
      setDocumentContent(updatedDoc.documentation);
      setNotify("Document updated successfully");
    } catch (error) {
      console.error("Error updating document:", error);
      setNotify("Error updating document");
    } finally {
      setLoading(false);
    }
  };

  const handleTagToggle = (tagType, name) => {
    setSelectedTags((prevTags) => {
      const tagKey = `${tagType}:${name}`;
      return prevTags.some((t) => t.tagType === tagType && t.name === name)
        ? prevTags.filter((t) => !(t.tagType === tagType && t.name === name))
        : [...prevTags, { tagType, name }];
    });
  };

  const handleViewMoreArtifacts = () => {
    navigate("/artifact");
  };

  return (
    <Box
      sx={{
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        maxWidth: "1200px",
        width: "calc(90vw - 260px);",
        minWidth: "320px",
      }}
    >
      <Box
        sx={{
          width: "100%",
          mt: 4,
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
        }}
        maxWidth="layout"
      >
        <Typography variant="h4" gutterBottom>
          Recent Artifacts
        </Typography>
        <Button variant="contained" onClick={() => setModalOpen(true)}>
          Create Artifact
        </Button>
      </Box>
      <Box
        sx={{
          flexGrow: 1,
          p: 2,
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          width: "100%",
        }}
      >
        <Box
          className="flex flex-col flex-wrap md:flex-row gap-3 items-start w-full"
          sx={{ 
            maxWidth: CONTENT_MAX_WIDTH, 
            width: "100%",
            minHeight: "200px", // Ensure minimum height even when empty
          }}
        >
          {documents?.map((doc) => {
            if (doc.document?.id) {
              return (
                <DocumentCard
                  key={doc.document.lastModified}
                  document={doc.document}
                  onEdit={handleDocumentUpdate}
                  onDelete={handleDocumentDelete}
                  isDeleting={deletingDocumentId === doc.document.id}
                  versions={doc.versions}
                />
              );
            }
            return null;
          })}
        </Box>
        <Button 
          variant="outlined" 
          onClick={handleViewMoreArtifacts} 
          sx={{ mt: 4, mb: 2 }}
        >
          View More Artifacts
        </Button>
      </Box>
      <Modal
        open={modalOpen}
        onClose={() => setModalOpen(false)}
        aria-labelledby="add-document-modal"
      >
        <Box
          sx={{
            position: "absolute",
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)",
            width: "60%",
            minWidth: "300px",
            bgcolor: "background.paper",
            boxShadow: 24,
            p: 4,
          }}
        >
          <Typography variant="h6" gutterBottom>
            Add New Artifact
          </Typography>
          <TextField
            fullWidth
            label="Artifact Title"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            margin="normal"
          />
          <TextField
            fullWidth
            label="Prompt"
            value={prompt}
            onChange={(e) => setPrompt(e.target.value)}
            margin="normal"
            multiline
            rows={6}
          />
          <div className="flex flex-wrap gap-4 justify-between items-center">
            <Box sx={{ mt: 2, mb: 2, minWidth: "300px" }}>
              <Typography variant="subtitle2" gutterBottom>
                Tags:
              </Typography>
              <Box sx={{ display: "flex", flexWrap: "wrap", gap: 1 }}>
                {tags.map((tag) => {
                  if (tag.tagType === "TopicTag") return null;
                  return (
                    <Chip
                      key={`${tag.tagType}:${tag.name}`}
                      label={tag.name}
                      onClick={() => handleTagToggle(tag.tagType, tag.name)}
                      color={
                        selectedTags.some(
                          (t) =>
                            t.tagType === tag.tagType && t.name === tag.name
                        )
                          ? "primary"
                          : "default"
                      }
                      size="small"
                      sx={{
                        borderRadius: "4px",
                        fontSize: "0.75rem",
                        height: "24px",
                        "& .MuiChip-label": {
                          padding: "0 8px",
                        },
                      }}
                    />
                  );
                })}
              </Box>
            </Box>
            <Box sx={{ mt: 2, mb: 2, minWidth: "300px" }}>
              <Typography variant="subtitle2" gutterBottom>
                Topic Tags:
              </Typography>
              <Box sx={{ display: "flex", flexWrap: "wrap", gap: 1 }}>
                {tags.map((tag) => {
                  if (tag.tagType === "Tag") return null;
                  return (
                    <Chip
                      key={`${tag.tagType}:${tag.name}`}
                      label={tag.name}
                      onClick={() => handleTagToggle(tag.tagType, tag.name)}
                      color={
                        selectedTags.some(
                          (t) =>
                            t.tagType === tag.tagType && t.name === tag.name
                        )
                          ? "primary"
                          : "default"
                      }
                      size="small"
                      sx={{
                        borderRadius: "4px",
                        fontSize: "0.75rem",
                        height: "24px",
                        "& .MuiChip-label": {
                          padding: "0 8px",
                        },
                      }}
                    />
                  );
                })}
              </Box>
            </Box>
          </div>
          <Button
            variant="contained"
            onClick={handleDocumentAdd}
            disabled={loading}
            sx={{ mt: 2 }}
          >
            {loading ? <CircularProgress size={24} /> : "Generate Artifact"}
          </Button>
        </Box>
      </Modal>
    </Box>
  );
};

export default DocBuilder;
<<< END ./client/src/components/DocBuilder/DocBuilder.jsx >>>

--- FILE: ./client/src/components/Documentation/Documentation.jsx ---

<<< BEGIN ./client/src/components/Documentation/Documentation.jsx >>>
import React from 'react';
import DocumentationTab from './DocumentationTab';

const Documentation = ({ setNotify }) => {
  return <DocumentationTab setNotify={setNotify} />;
};

export default Documentation;
<<< END ./client/src/components/Documentation/Documentation.jsx >>>

--- FILE: ./client/src/components/Documentation/DocumentationTab.jsx ---

<<< BEGIN ./client/src/components/Documentation/DocumentationTab.jsx >>>
import React, { useState, useEffect } from "react";
import {
  Box,
  Typography,
  TextField,
  Button,
} from "@mui/material";
import ReactMarkdown from 'react-markdown';
import axios from "axios";
import MiniSidebar from "../_molecules/MiniSidebar";

const MINI_SIDEBAR_WIDTH = 250;
const CONTENT_MAX_WIDTH = 950;

const Documentation = ({ setNotify }) => {
  const [documentation, setDocumentation] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [editContent, setEditContent] = useState("");

  useEffect(() => {
    fetchDocumentation();
  }, []);

  const fetchDocumentation = async () => {
    try {
      const response = await axios.get("/api/documentation");
      console.log("FETCHED DOCS\n",response.data)
      setDocumentation(response.data);
      setEditContent(response.data.documentation.content);
    } catch (error) {
      console.error("Error fetching documentation:", error);
      setNotify("Error fetching documentation");
    }
  };

  const handleSave = async () => {
    try {
      await axios.post("/api/documentation/refresh", { content: editContent });
      setDocumentation({ ...documentation, content: editContent });
      setIsEditing(false);
      setNotify("Documentation updated successfully");
    } catch (error) {
      console.error("Error updating documentation:", error);
      setNotify("Error updating documentation");
    }
  };

  return (
    <Box sx={{ 
      flexGrow: 1, 
      p: 2, 
      overflowY: 'auto', 
      display: 'flex', 
      justifyContent: 'center'
    }}>
      <Box sx={{ maxWidth: CONTENT_MAX_WIDTH, width: '100%' }}>
        <Typography variant="h5" gutterBottom>Documentation</Typography>
        {documentation ? (
          <>
            <Box sx={{ mb: 2 }}>
              <Button onClick={() => setIsEditing(!isEditing)}>
                {isEditing ? 'Cancel' : 'Edit Documentation'}
              </Button>
            </Box>
            {isEditing ? (
              <Box>
                <TextField
                  fullWidth
                  multiline
                  rows={20}
                  value={editContent}
                  onChange={(e) => setEditContent(e.target.value)}
                  variant="outlined"
                  sx={{ mb: 2 }}
                />
                <Button variant="contained" onClick={handleSave}>
                  Save
                </Button>
              </Box>
            ) : (
              <ReactMarkdown>
                {documentation.content}
              </ReactMarkdown>
            )}
          </>
        ) : (
          <Typography>Loading documentation...ErroE</Typography>
        )}
      </Box>
    </Box>
  );
};

export default Documentation;
<<< END ./client/src/components/Documentation/DocumentationTab.jsx >>>

--- FILE: ./client/src/components/FactGenerator/DataLoader.jsx ---

<<< BEGIN ./client/src/components/FactGenerator/DataLoader.jsx >>>
import React, { useEffect, useRef } from "react";
import axios from "axios";
import logger from "../../../../shared/logger.js";

const DataLoader = ({ setDistinctFacts, setIsLoading, setDebugMessage }) => {
  const hasFetchedData = useRef(false);

  useEffect(() => {
    const loadData = async () => {
      if (hasFetchedData.current) return;
      hasFetchedData.current = true;

      try {
        setIsLoading(true);
        setDebugMessage("Loading facts...");
        logger.info("DataLoader: Starting to fetch facts");

        logger.info("API Request: GET /api/facts");
        const { data } = await axios.get("/api/facts");
        logger.info(
          `API Response: GET /api/facts, Data: ${JSON.stringify(data)}`,
        );

        logger.data("DataLoader: Fetched facts", data.facts);

        setDistinctFacts(data.facts);

        logger.success("DataLoader: Facts loaded successfully");
        setDebugMessage("Facts loaded successfully");
      } catch (error) {
        logger.error(`DataLoader: Error in loadData: ${error.message}`);
        setDebugMessage(`Error: ${error.message}`);
        console.error("Full error details:", error);
      } finally {
        setIsLoading(false);
        logger.info("DataLoader: Loading state set to false");
      }
    };

    loadData();
  }, [setDistinctFacts, setDebugMessage, setIsLoading]);

  return null;
};

export default DataLoader;

<<< END ./client/src/components/FactGenerator/DataLoader.jsx >>>

--- FILE: ./client/src/components/FactGenerator/FactGenerator.jsx ---

<<< BEGIN ./client/src/components/FactGenerator/FactGenerator.jsx >>>
import React from 'react';
import InputForm from "../_molecules/InputForm";
import FactReviewModal from "../_organisms/FactReviewModal";
import FactDisplay from "../_organisms/FactDisplay";
import DataLoader from "./DataLoader";

const FactGenerator = ({
  inputText,
  setInputText,
  distinctFacts,
  setDistinctFacts,
  isLoading,
  setIsLoading,
  showFactReview,
  factsToReview,
  handleSubmit,
  handleFactReviewComplete,
  setDebugMessage,
}) => {
  const handleInputSubmit = (text) => {
    if (text && typeof text === 'string' && text.trim()) {
      handleSubmit(text);
      setInputText('');
    }
  };

  return (
    <>
      <DataLoader
        setDistinctFacts={setDistinctFacts}
        setIsLoading={setIsLoading}
        setDebugMessage={setDebugMessage}
      />
      <InputForm
        onSubmit={handleInputSubmit}
        value={inputText || ''}
        onChange={setInputText}
      />
      {showFactReview && (
        <FactReviewModal
          sustained={factsToReview.sustained || []}
          newFacts={factsToReview.new || []}
          conflicts={factsToReview.conflicts || []}
          onComplete={handleFactReviewComplete}
        />
      )}
      {!isLoading && !showFactReview && (
        <FactDisplay facts={distinctFacts || ''} />
      )}
    </>
  );
};

export default FactGenerator;
<<< END ./client/src/components/FactGenerator/FactGenerator.jsx >>>

--- FILE: ./client/src/components/Inbox/Inbox.jsx ---

<<< BEGIN ./client/src/components/Inbox/Inbox.jsx >>>
import React, { useState, useEffect } from 'react';
import { Box, Typography, List, ListItem, ListItemText, Button } from '@mui/material';
import axios from 'axios';

const Inbox = () => {
  const [apiCalls, setApiCalls] = useState([]);
  const [error, setError] = useState(null);

  const fetchApiCalls = async () => {
    try {
      const response = await axios.get('/api/api-calls');
      setApiCalls(Array.isArray(response.data) ? response.data : []);
      setError(null);
    } catch (error) {
      console.error('Error fetching API calls:', error);
      setError('Failed to fetch API calls. Please try again.');
      setApiCalls([]);
    }
  };

  useEffect(() => {
    fetchApiCalls();
  }, []);

  return (
    <Box sx={{ width: '100%', mx: 'auto', mt: 4 }} maxWidth="layout">
      <Typography variant="h4" gutterBottom>
        API Call Inbox
      </Typography>
      <Button onClick={fetchApiCalls} variant="contained" sx={{ mb: 2 }}>
        Refresh
      </Button>
      {error && (
        <Typography color="error" sx={{ mb: 2 }}>
          {error}
        </Typography>
      )}
      {apiCalls.length === 0 ? (
        <Typography>No API calls to display.</Typography>
      ) : (
        <List>
          {apiCalls.map((call, index) => (
            <ListItem key={index} divider>
              <ListItemText
                primary={`${new Date(call.timestamp).toLocaleString()} - Input: ${call.inputTokens}, Output: ${call.outputTokens}`}
                secondary={call.message}
              />
            </ListItem>
          ))}
        </List>
      )}
    </Box>
  );
};

export default Inbox;
<<< END ./client/src/components/Inbox/Inbox.jsx >>>

--- FILE: ./client/src/components/Layouts/Layout.jsx ---

<<< BEGIN ./client/src/components/Layouts/Layout.jsx >>>
import React, { useState } from "react";
import { Link, useLocation } from "react-router-dom";
import {
  Box,
  AppBar,
  Toolbar,
  Typography,
  IconButton,
  useTheme,
} from "@mui/material";
import MenuIcon from "@mui/icons-material/Menu";
import Brightness4Icon from "@mui/icons-material/Brightness4";
import Brightness7Icon from "@mui/icons-material/Brightness7";
import Sidebar from "../_organisms/Sidebar";

const DRAWER_WIDTH = 240;
const MAIN_CONTENT_MAX_WIDTH = 1200;
const MINI_SIDEBAR_WIDTH = 250;

const Layout = ({ children, toggleTheme, mode }) => {
  const [sidebarOpen, setSidebarOpen] = useState(true);
  const theme = useTheme();
  const location = useLocation();

  const toggleSidebar = () => setSidebarOpen(!sidebarOpen);

  const isDocPage =
    location.pathname === "/documentation" ||
    location.pathname === "/doc-builder";

  return (
    <Box sx={{ display: "flex" }}>
      <AppBar
        position="fixed"
        sx={{
          zIndex: (theme) => theme.zIndex.drawer + 1,
          width: "100%",
        }}
      >
        <Toolbar>
          <IconButton
            color="inherit"
            aria-label="toggle drawer"
            edge="start"
            onClick={toggleSidebar}
            sx={{ mr: 2 }}
          >
            <MenuIcon />
          </IconButton>
            <Typography variant="h6" noWrap component="div" sx={{ flexGrow: 1 }}>
            Latent Knowledge
          </Typography>
          <IconButton sx={{ ml: 1 }} onClick={toggleTheme} color="inherit">
            {mode === "dark" ? <Brightness7Icon /> : <Brightness4Icon />}
          </IconButton>
        </Toolbar>
      </AppBar>
      <Sidebar
        open={sidebarOpen}
        activeItem={location.pathname}
        drawerWidth={DRAWER_WIDTH}
      />
      <Box
        component="main"
        sx={{
          flexGrow: 1,
          p: 3,
          width: "100%",
          mt: ["48px", "56px", "64px"],
          // ml: sidebarOpen ? `${DRAWER_WIDTH}px` : 0,
          transition: theme.transitions.create("margin", {
            easing: theme.transitions.easing.sharp,
            duration: theme.transitions.duration.leavingScreen,
          }),
        }}
      >
        {isDocPage ? (
          <Box sx={{ display: "flex" }}>{children}</Box>
        ) : (
          <Box
            sx={{
              maxWidth: `${MAIN_CONTENT_MAX_WIDTH}px`,
              width: "100%",
              mx: "auto",
            }}
          >
            {children}
          </Box>
        )}
      </Box>
    </Box>
  );
};

export default Layout;

<<< END ./client/src/components/Layouts/Layout.jsx >>>

--- FILE: ./client/src/components/MainContent.jsx ---

<<< BEGIN ./client/src/components/MainContent.jsx >>>
// File: ./client/src/components/MainContent.jsx

import React, { lazy, Suspense } from 'react';
import { CircularProgress } from "@mui/material";
import FactGenerator from "./FactGenerator/FactGenerator";
import DocBuilder from "./DocBuilder/DocBuilder";
import DatabaseSchema from "./DatabaseSchema/DatabaseSchema";
import Documentation from "./Documentation/Documentation";
import Inbox from "./Inbox/Inbox";

const RepositoryUpload = lazy(() => import("./RepositoryUpload/RepositoryUpload"));

const MainContent = ({
  activeItem,
  inputText,
  setInputText,
  distinctFacts,
  setDistinctFacts,
  isLoading,
  setIsLoading,
  showFactReview,
  factsToReview,
  handleSubmit,
  handleFactReviewComplete,
  setDebugMessage,
  setNotify
}) => {
  const renderContent = () => {
    switch (activeItem) {
      case "Fact Generator":
        return (
          <FactGenerator
            inputText={inputText}
            setInputText={setInputText}
            distinctFacts={distinctFacts}
            setDistinctFacts={setDistinctFacts}
            isLoading={isLoading}
            setIsLoading={setIsLoading}
            showFactReview={showFactReview}
            factsToReview={factsToReview}
            handleSubmit={handleSubmit}
            handleFactReviewComplete={handleFactReviewComplete}
            setDebugMessage={setDebugMessage}
          />
        );
      case "Repository Upload":
        return (
          <Suspense fallback={<CircularProgress />}>
            <RepositoryUpload
              setIsLoading={setIsLoading}
              setNotify={setNotify}
              setDebugMessage={setDebugMessage}
            />
          </Suspense>
        );
      case "Documentation":
        return <Documentation setNotify={setNotify} />;
      case "DocBuilder":
        return <DocBuilder setNotify={setNotify} />;
      case "Database Schema":
        return <DatabaseSchema setNotify={setNotify} />;
      case "Inbox":
        return <Inbox />;
      default:
        return <div>Select an item from the sidebar</div>;
    }
  };

  return renderContent();
};

export default MainContent;
<<< END ./client/src/components/MainContent.jsx >>>

--- FILE: ./client/src/components/RepositoryUpload/FileDetailModal.jsx ---

<<< BEGIN ./client/src/components/RepositoryUpload/FileDetailModal.jsx >>>
// File: ./client/src/components/FileDetailModal.jsx
import React from "react";
import { Modal, Box, Typography } from "@mui/material";
import MermaidDiagram from "../_atoms/MermaidDiagram";

const FileDetailModal = ({ open, onClose, fileDetails }) => {
  if (!fileDetails) return null;
  const {
    title,
    filePath,
    fileSize,
    lastUpdated,
    documentation,
    mermaidDiagram,
  } = fileDetails.documentation;

  return (
    <Modal open={open} onClose={onClose} aria-labelledby="file-detail-modal">
      <Box
        sx={{
          position: "absolute",
          top: "50%",
          left: "50%",
          transform: "translate(-50%, -50%)",
          width: "80%",
          maxWidth: 600,
          maxHeight: "90vh",
          overflowY: "auto",
          bgcolor: "background.paper",
          boxShadow: 24,
          borderRadius: 2,
          p: 4,
        }}
      >
        <Typography variant="h5" component="h2" gutterBottom>
          {title}
        </Typography>
        <Typography variant="body2" color="text.secondary" paragraph>
          File Path: {filePath}
        </Typography>
        <Typography variant="body2" color="text.secondary" paragraph>
          File Size: {fileSize}
        </Typography>
        <Typography variant="body2" color="text.secondary" paragraph>
          Last Updated: {lastUpdated}
        </Typography>
        <Typography variant="h6" gutterBottom sx={{ mt: 3 }}>
          Documentation
        </Typography>
        <Typography variant="body2" sx={{ whiteSpace: "pre-wrap", mb: 3 }}>
          {documentation || "No documentation available."}
        </Typography>
        <Typography variant="h6" gutterBottom>
          Mermaid Diagram
        </Typography>
        <Box sx={{ mt: 2, mb: 2 }}>
          <MermaidDiagram diagram={mermaidDiagram} />
        </Box>
      </Box>
    </Modal>
  );
};

export default FileDetailModal;

<<< END ./client/src/components/RepositoryUpload/FileDetailModal.jsx >>>

--- FILE: ./client/src/components/RepositoryUpload/RepositoryUpload.jsx ---

<<< BEGIN ./client/src/components/RepositoryUpload/RepositoryUpload.jsx >>>
// File: ./client/src/components/RepositoryUpload/RepositoryUpload.jsx

import React, { useState, useEffect } from 'react';
import { 
  Box, 
  Typography, 
  IconButton, 
  List, 
  ListItem, 
  ListItemIcon, 
  ListItemText, 
  ListItemSecondaryAction,
  Collapse,
  CircularProgress,
  useTheme,
  useMediaQuery
} from '@mui/material';
import RefreshIcon from '@mui/icons-material/Refresh';
import DeleteIcon from '@mui/icons-material/Delete';
import FolderIcon from '@mui/icons-material/Folder';
import InsertDriveFileIcon from '@mui/icons-material/InsertDriveFile';
import InfoIcon from '@mui/icons-material/Info';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import ExpandLessIcon from '@mui/icons-material/ExpandLess';
import axios from 'axios';
import FileDetailModal from './FileDetailModal';

const getTimeAgo = (date) => {
  const seconds = Math.floor((new Date() - new Date(date)) / 1000);
  let interval = seconds / 31536000;
  if (interval > 1) return Math.floor(interval) + "y ago";
  interval = seconds / 2592000;
  if (interval > 1) return Math.floor(interval) + "m ago";
  interval = seconds / 86400;
  if (interval > 1) return Math.floor(interval) + "d ago";
  interval = seconds / 3600;
  if (interval > 1) return Math.floor(interval) + "h ago";
  interval = seconds / 60;
  if (interval > 1) return Math.floor(interval) + "m ago";
  return Math.floor(seconds) + "s ago";
};

const formatFileSize = (bytes) => {
  const kb = bytes / 1024;
  return kb < 1 ? `${bytes} B` : `${kb.toFixed(1)} KB`;
};

const FileTreeNode = ({ item, level, onRefresh, onDelete, processingNodes, onDetails, expanded, onToggle }) => {
  const theme = useTheme();
  const isSmallScreen = useMediaQuery(theme.breakpoints.down('sm'));

  const getNodeColor = (status) => {
    switch (status) {
      case 'new': return theme.palette.success.main;
      case 'modified': return theme.palette.warning.main;
      case 'deleted': return theme.palette.error.main;
      default: return 'inherit';
    }
  };

  const isProcessing = processingNodes.has(item.id);

  return (
    <ListItem 
      sx={{ 
        pl: level * 2, 
        py: 0.5,
        minHeight: '48px',
        '&:hover': {
          backgroundColor: theme.palette.action.hover,
        },
        position: 'relative', // Add this
      }}
    >
      <Box sx={{ 
        position: 'absolute', 
        top: 0, 
        left: 0, 
        right: 0, 
        bottom: 0, 
        zIndex: 0,
        '&:hover': {
          backgroundColor: theme.palette.action.hover,
        },
      }} />
      <ListItemIcon sx={{ minWidth: 24, display: 'flex', alignItems: 'center', zIndex: 1 }}>
        {item.type === 'directory' 
          ? <FolderIcon fontSize="small" color="primary" /> 
          : <InsertDriveFileIcon fontSize="small" sx={{ color: theme.palette.text.secondary }} />
        }
      </ListItemIcon>
      <ListItemText
        primary={
          <Typography variant="body2" sx={{ color: getNodeColor(item.status), fontWeight: item.type === 'directory' ? 'bold' : 'normal' }}>
            {item.name}
          </Typography>
        }
        secondary={
          item.type === 'file' && !isSmallScreen && (
            <Typography variant="caption" color="text.secondary" sx={{ fontSize: '0.7rem' }}>
              Last updated: {getTimeAgo(item.modifiedAt)} ({formatFileSize(item.size)})
            </Typography>
          )
        }
        sx={{ my: 0, display: 'flex', flexDirection: 'column', justifyContent: 'center', zIndex: 1 }}
      />
      <ListItemSecondaryAction sx={{ zIndex: 1 }}>
        {isProcessing ? (
          <CircularProgress size={20} />
        ) : (
          <>
            {item.type === 'file' && (
              <IconButton
                edge="end"
                aria-label="view details"
                onClick={() => onDetails(item)}
                size="small"
                sx={{ color: theme.palette.primary.main }}
              >
                <InfoIcon fontSize="small" />
              </IconButton>
            )}
            {item.type === 'directory' && (
              <IconButton
                edge="end"
                aria-label={expanded ? 'collapse' : 'expand'}
                onClick={() => onToggle(item.id)}
                size="small"
              >
                {expanded ? <ExpandLessIcon fontSize="small" /> : <ExpandMoreIcon fontSize="small" />}
              </IconButton>
            )}
            <IconButton
              edge="end"
              aria-label="refresh"
              onClick={() => onRefresh(item.id, item.type === 'directory')}
              size="small"
              sx={{ color: theme.palette.info.main }}
            >
              <RefreshIcon fontSize="small" />
            </IconButton>
            <IconButton
              edge="end"
              aria-label="delete"
              onClick={() => onDelete(item.id, item.type === 'directory')}
              size="small"
              sx={{ color: theme.palette.error.main }}
            >
              <DeleteIcon fontSize="small" />
            </IconButton>
          </>
        )}
      </ListItemSecondaryAction>
    </ListItem>
  );
};

const RepositoryUpload = ({ setIsLoading, setNotify, setDebugMessage }) => {
  const [fileTree, setFileTree] = useState(null);
  const [processingNodes, setProcessingNodes] = useState(new Set());
  const [selectedFile, setSelectedFile] = useState(null);
  const [isModalOpen, setModalOpen] = useState(false);
  const [expandedNodes, setExpandedNodes] = useState(new Set());
  const theme = useTheme();

  useEffect(() => {
    fetchFileTree();
  }, []);

  const expandAllNodes = (node) => {
    let allNodeIds = new Set();
    const traverseTree = (node) => {
      if (node.type === 'directory') {
        allNodeIds.add(node.id);
        if (node.children) {
          node.children.forEach(traverseTree);
        }
      }
    };
    traverseTree(node);
    return allNodeIds;
  };

  const fetchFileTree = async () => {
    setIsLoading(true);
    try {
      const response = await axios.get('/api/repository/files');
      setFileTree(response.data.fileTree);
      setExpandedNodes(expandAllNodes(response.data.fileTree));
    } catch (error) {
      console.error('Error fetching file tree:', error);
      setNotify('Error fetching file tree');
      setDebugMessage(error.message);
    } finally {
      setIsLoading(false);
    }
  };

  const handleFileAction = async (action, nodePath, isFolder) => {
    setProcessingNodes(prev => new Set(prev).add(nodePath));
    try {
      let endpoint = isFolder ? `/api/repository/folder/${action}` : `/api/repository/file/${action}`;
      await axios.post(endpoint, { [isFolder ? 'folderPath' : 'filePath']: nodePath });
      setNotify(`${isFolder ? 'Folder' : 'File'} ${action} successful`);
      fetchFileTree();
    } catch (error) {
      console.error(`Error during ${isFolder ? 'folder' : 'file'} ${action}:`, error);
      setNotify(`Error during ${isFolder ? 'folder' : 'file'} ${action}`);
      setDebugMessage(error.message);
    } finally {
      setProcessingNodes(prev => {
        const newSet = new Set(prev);
        newSet.delete(nodePath);
        return newSet;
      });
    }
  };

  const handleFileDetails = async (item) => {
    setIsLoading(true);
    try {
      const response = await axios.get(`/api/repository/file/mermaid/${encodeURIComponent(item.id)}`);
      const mermaidDiagram = response.data.mermaidDiagram || 'Mermaid diagram not found';

      // Fetch file details including documentation
      const fileDetailsResponse = await axios.get(`/api/repository/file/${encodeURIComponent(item.id)}`);
      const fileDetails = fileDetailsResponse.data;

      setSelectedFile({
        title: item.name,
        filePath: item.id,
        fileSize: formatFileSize(item.size),
        lastUpdated: getTimeAgo(item.modifiedAt),
        documentation: fileDetails.documentation || 'No documentation available.',
        mermaidDiagram: mermaidDiagram,
      });

      setModalOpen(true);
    } catch (error) {
      console.error('Error fetching file details:', error);
      setNotify('Error fetching file details');
    } finally {
      setIsLoading(false);
    }
  };

  const closeModal = () => {
    setModalOpen(false);
    setSelectedFile(null);
  };

  const toggleNodeExpansion = (nodeId) => {
    setExpandedNodes(prev => {
      const newSet = new Set(prev);
      if (newSet.has(nodeId)) {
        newSet.delete(nodeId);
      } else {
        newSet.add(nodeId);
      }
      return newSet;
    });
  };

  const renderFileTree = (node, level = 0) => {
    return (
      <React.Fragment key={node.id}>
        <FileTreeNode
          item={node}
          level={level}
          onRefresh={(id, isFolder) => handleFileAction('refresh', id, isFolder)}
          onDelete={(id, isFolder) => handleFileAction('delete', id, isFolder)}
          processingNodes={processingNodes}
          onDetails={handleFileDetails}
          expanded={expandedNodes.has(node.id)}
          onToggle={toggleNodeExpansion}
        />
        {node.children && expandedNodes.has(node.id) && (
          <Collapse in={expandedNodes.has(node.id)} timeout="auto" unmountOnExit>
            <List component="div" disablePadding>
              {node.children.map(child => renderFileTree(child, level + 1))}
            </List>
          </Collapse>
        )}
      </React.Fragment>
    );
  };

  return (
    <Box sx={{ width: '100%', maxWidth: '100%', overflowX: 'auto' }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
        <Typography variant="h6" component="h2">Repository Files</Typography>
        <IconButton onClick={fetchFileTree} color="primary">
          <RefreshIcon />
        </IconButton>
      </Box>

      {fileTree ? (
        <List dense sx={{ bgcolor: theme.palette.background.paper, borderRadius: 1, boxShadow: 1 }}>
          {renderFileTree(fileTree)}
        </List>
      ) : (
        <Typography variant="body2">No files found or still loading...</Typography>
      )}

      <FileDetailModal
        open={isModalOpen}
        onClose={closeModal}
        fileDetails={selectedFile}
      />
    </Box>
  );
};

export default RepositoryUpload;
<<< END ./client/src/components/RepositoryUpload/RepositoryUpload.jsx >>>

--- FILE: ./client/src/components/_atoms/Loader.jsx ---

<<< BEGIN ./client/src/components/_atoms/Loader.jsx >>>
// File: ./client/src/components/Loader.jsx

import React from "react";
import { CircularProgress, Backdrop } from "@mui/material";

const Loader = ({ isLoading }) => {
  return (
    <Backdrop
      sx={{ color: "#fff", zIndex: (theme) => theme.zIndex.drawer + 1 }}
      open={isLoading}
    >
      <CircularProgress color="inherit" />
    </Backdrop>
  );
};

export default Loader;

<<< END ./client/src/components/_atoms/Loader.jsx >>>

--- FILE: ./client/src/components/_atoms/Notification.jsx ---

<<< BEGIN ./client/src/components/_atoms/Notification.jsx >>>
// File: ./client/src/components/Notification.jsx

import React, { useEffect } from "react";
import { Snackbar, Alert } from "@mui/material";

const Notification = ({ message, clearMessage, duration = 3000 }) => {
  useEffect(() => {
    if (message) {
      const timer = setTimeout(() => {
        clearMessage();
      }, duration);
      return () => clearTimeout(timer);
    }
  }, [message, clearMessage, duration]);

  return (
    <Snackbar
      open={Boolean(message)}
      autoHideDuration={duration}
      onClose={clearMessage}
      anchorOrigin={{ vertical: "bottom", horizontal: "center" }}
    >
      <Alert
        onClose={clearMessage}
        severity={message.toLowerCase().includes("error") ? "error" : "success"}
        sx={{ width: "100%" }}
      >
        {message}
      </Alert>
    </Snackbar>
  );
};

export default Notification;

<<< END ./client/src/components/_atoms/Notification.jsx >>>

--- FILE: ./client/src/components/_atoms/MermaidDiagram.jsx ---

<<< BEGIN ./client/src/components/_atoms/MermaidDiagram.jsx >>>
import React, { useEffect } from 'react';
import mermaid from 'mermaid';
import { serializeDiagram } from '../../lib/utils';

mermaid.initialize({
  startOnLoad: true,
  theme: "default",
  securityLevel: "loose",
  themeCSS: `
    g.classGroup rect {
      fill: #282a36;
      stroke: #6272a4;
    } 
    g.classGroup text {
      fill: #f8f8f2;
    }
    g.classGroup line {
      stroke: #f8f8f2;
      stroke-width: 0.5;
    }
    .classLabel .box {
      stroke: #21222c;
      stroke-width: 3;
      fill: #21222c;
      opacity: 1;
    }
    .classLabel .label {
      fill: #f1fa8c;
    }
    .relation {
      stroke: #ff79c6;
      stroke-width: 1;
    }
    #compositionStart, #compositionEnd {
      fill: #bd93f9;
      stroke: #bd93f9;
      stroke-width: 1;
    }
    #aggregationEnd, #aggregationStart {
      fill: #21222c;
      stroke: #50fa7b;
      stroke-width: 1;
    }
    #dependencyStart, #dependencyEnd {
      fill: #00bcd4;
      stroke: #00bcd4;
      stroke-width: 1;
    } 
    #extensionStart, #extensionEnd {
      fill: #f8f8f2;
      stroke: #f8f8f2;
      stroke-width: 1;
    }`,
  fontFamily: "Fira Code"
});

const MermaidDiagram = ({ diagram }) => {
  useEffect(() => {
    mermaid.contentLoaded();
  }, []);
 console.log(serializeDiagram(diagram))
  return <div className="mermaid">{serializeDiagram(diagram)}</div>;
};

export default MermaidDiagram;
<<< END ./client/src/components/_atoms/MermaidDiagram.jsx >>>

--- FILE: ./client/src/components/_molecules/FactItem.jsx ---

<<< BEGIN ./client/src/components/_molecules/FactItem.jsx >>>
import React from "react";
import { Typography, IconButton, Box, Fab } from "@mui/material";
import CheckCircleIcon from "@mui/icons-material/CheckCircle";
import CancelIcon from "@mui/icons-material/Cancel";
import ArrowForwardIcon from "@mui/icons-material/ArrowForward";

function FactItem({
  fact,
  type,
  onReview,
  reviewedStatus,
  buttonStyles,
  iconStyles,
}) {
  const renderFactButtons = () => (
    <Box sx={{ display: "flex", gap: 1, ml: 1, alignItems: "center" }}>
      <IconButton
        size="small"
        onClick={() => onReview(fact.id, false)}
        sx={{
          ...buttonStyles,
          color: reviewedStatus === false ? "error.main" : "action.disabled",
          opacity: reviewedStatus === false ? 1 : 0.5,
          "&:hover": { color: "error.dark", opacity: 1 },
        }}
      >
        <CancelIcon sx={iconStyles} />
      </IconButton>
      <IconButton
        size="small"
        onClick={() => onReview(fact.id, true)}
        sx={{
          ...buttonStyles,
          color: reviewedStatus === true ? "success.main" : "action.disabled",
          opacity: reviewedStatus === true ? 1 : 0.5,
          "&:hover": { color: "success.dark", opacity: 1 },
        }}
      >
        <CheckCircleIcon sx={iconStyles} />
      </IconButton>
    </Box>
  );

  return (
    <Box sx={{ mb: 1.5, display: "flex", alignItems: "center" }}>
      <Box sx={{ flexGrow: 1, display: "flex", alignItems: "center" }}>
        {type === "conflict" ? (
          <>
            <Typography
              variant="body2"
              sx={{ flex: 1, textAlign: "right", pr: 1 }}
            >
              <span style={{ textDecoration: "line-through" }}>
                {fact.oldFact}
              </span>
            </Typography>
            <ArrowForwardIcon fontSize="small" sx={{ flexShrink: 0 }} />
            <Typography variant="body2" sx={{ flex: 1, pl: 1 }}>
              {fact.newFact}
            </Typography>
          </>
        ) : (
          <Typography variant="body2">{fact.fact}</Typography>
        )}
      </Box>
      {renderFactButtons()}
    </Box>
  );
}

export default FactItem;

<<< END ./client/src/components/_molecules/FactItem.jsx >>>

--- FILE: ./client/src/components/_molecules/InputForm.jsx ---

<<< BEGIN ./client/src/components/_molecules/InputForm.jsx >>>
import React from "react";
import { TextField, Button, Box } from "@mui/material";

function InputForm({ onSubmit, value, onChange }) {
  const handleSubmit = (e) => {
    e.preventDefault();
    if (value && typeof value === 'string' && value.trim()) {
      onSubmit(value);
    }
  };

  return (
    <Box component="form" onSubmit={handleSubmit} sx={{ mt: 2, mb: 2 }}>
      <TextField
        fullWidth
        multiline
        rows={4}
        value={value || ''}
        onChange={(e) => onChange(e.target.value)}
        placeholder="Enter text here..."
        variant="outlined"
        sx={{ mb: 2 }}
      />
      <Button
        type="submit"
        variant="contained"
        color="primary"
        disabled={!value || typeof value !== 'string' || !value.trim()}
      >
        Generate Facts
      </Button>
    </Box>
  );
}

export default InputForm;
<<< END ./client/src/components/_molecules/InputForm.jsx >>>

--- FILE: ./client/src/components/_molecules/MiniSidebar.jsx ---

<<< BEGIN ./client/src/components/_molecules/MiniSidebar.jsx >>>
import React, { useState } from 'react';
import {
  Box,
  List,
  ListItem,
  ListItemText,
  IconButton,
  Button,
  Dialog,
  DialogActions,
  DialogContent,
  DialogContentText,
  DialogTitle,
  TextField,
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import DeleteIcon from '@mui/icons-material/Delete';

const MiniSidebar = ({ items = [], onItemSelect, onItemAdd, onItemDelete, selectedItem }) => {
  const [newItemDialogOpen, setNewItemDialogOpen] = useState(false);
  const [deleteConfirmDialogOpen, setDeleteConfirmDialogOpen] = useState(false);
  const [itemToDelete, setItemToDelete] = useState(null);
  const [newItemName, setNewItemName] = useState('');

  const handleNewItemClick = () => {
    setNewItemDialogOpen(true);
  };

  const handleNewItemClose = () => {
    setNewItemDialogOpen(false);
    setNewItemName('');
  };

  const handleNewItemSubmit = () => {
    if (newItemName.trim()) {
      onItemAdd(newItemName.trim());
      handleNewItemClose();
    }
  };

  const handleDeleteClick = (item) => {
    setItemToDelete(item);
    setDeleteConfirmDialogOpen(true);
  };

  const handleDeleteConfirm = () => {
    if (itemToDelete) {
      onItemDelete(itemToDelete);
      setDeleteConfirmDialogOpen(false);
      setItemToDelete(null);
    }
  };

  return (
    <Box sx={{ width: 250, borderRight: 1, borderColor: 'divider', overflowY: 'auto' }}>
      <Button
        startIcon={<AddIcon />}
        onClick={handleNewItemClick}
        fullWidth
        sx={{ my: 1 }}
      >
        New Item
      </Button>
      <List>
        {Array.isArray(items) && items.map((item) => (
          <ListItem
            key={item.id}
            selected={selectedItem && selectedItem.id === item.id}
            secondaryAction={
              <IconButton edge="end" aria-label="delete" onClick={() => handleDeleteClick(item)}>
                <DeleteIcon />
              </IconButton>
            }
          >
            <ListItemText
              primary={item.title}
              onClick={() => onItemSelect(item)}
              sx={{ cursor: 'pointer' }}
            />
          </ListItem>
        ))}
      </List>
  
      {/* Dialog components... */}
    </Box>
  );
};
  
export default MiniSidebar;
<<< END ./client/src/components/_molecules/MiniSidebar.jsx >>>

--- FILE: ./client/src/components/_molecules/PromptEditor.jsx ---

<<< BEGIN ./client/src/components/_molecules/PromptEditor.jsx >>>
import React, { useState } from 'react';
import { Box, TextField, Button } from '@mui/material';

const PromptEditor = ({ initialPrompt, onSave }) => {
  const [prompt, setPrompt] = useState(initialPrompt);

  const handleSave = () => {
    onSave(prompt);
  };

  return (
    <Box>
      <TextField
        fullWidth
        multiline
        rows={4}
        value={prompt}
        onChange={(e) => setPrompt(e.target.value)}
        variant="outlined"
        sx={{ mb: 2 }}
      />
      <Button variant="contained" onClick={handleSave}>
        Save & Generate
      </Button>
    </Box>
  );
};

export default PromptEditor;
<<< END ./client/src/components/_molecules/PromptEditor.jsx >>>

--- FILE: ./client/src/components/_molecules/FileTreeItem.jsx ---

<<< BEGIN ./client/src/components/_molecules/FileTreeItem.jsx >>>
import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import {
  ListItem,
  ListItemIcon,
  ListItemText,
  Collapse,
  List,
  IconButton,
} from '@mui/material';
import {
  Folder as FolderIcon,
  FolderOpen as FolderOpenIcon,
  InsertDriveFile as FileIcon,
  ExpandMore as ExpandMoreIcon,
  ExpandLess as ExpandLessIcon,
} from '@mui/icons-material';

const FileTreeItem = ({ item, depth = 0 }) => {
  const [open, setOpen] = useState(false);

  const handleToggle = () => {
    setOpen(!open);
  };

  const isDirectory = item.type === 'directory';

  return (
    <>
      <ListItem
        button
        onClick={isDirectory ? handleToggle : undefined}
        sx={{ pl: 2 * depth }}
      >
        <ListItemIcon>
          {isDirectory ? (
            open ? <FolderOpenIcon /> : <FolderIcon />
          ) : (
            <FileIcon />
          )}
        </ListItemIcon>
        <ListItemText
          primary={
            isDirectory ? (
              item.name
            ) : (
              <Link
                to={`/file/${encodeURIComponent(item.id)}`}
                style={{ textDecoration: 'none', color: 'inherit',width:'100%' }}
              >
                {item.name}
              </Link>
            )
          }
          secondary={
            !isDirectory &&
            `${item.size !== undefined ? `${item.size} bytes` : 'N/A'} | ${
              item.modifiedAt ? new Date(item.modifiedAt).toLocaleString() : 'N/A'
            }`
          }
        />
        {isDirectory && (
          <IconButton edge="end" onClick={handleToggle} size="small">
            {open ? <ExpandLessIcon /> : <ExpandMoreIcon />}
          </IconButton>
        )}
      </ListItem>
      {isDirectory && (
        <Collapse in={open} timeout="auto" unmountOnExit>
          <List component="div" disablePadding>
            {item.children.map((childItem) => (
              <FileTreeItem key={childItem.id} item={childItem} depth={depth + 1} />
            ))}
          </List>
        </Collapse>
      )}
    </>
  );
};

export default FileTreeItem;
<<< END ./client/src/components/_molecules/FileTreeItem.jsx >>>

--- FILE: ./client/src/components/_molecules/DocumentCard.jsx ---

<<< BEGIN ./client/src/components/_molecules/DocumentCard.jsx >>>
import React, { useState, useMemo, useEffect } from "react";
import { Link } from "react-router-dom";
import {
  Card,
  CardContent,
  Typography,
  IconButton,
  Modal,
  Box,
  TextField,
  Button,
  CircularProgress,
  Dialog,
  DialogActions,
  DialogContent,
  DialogContentText,
  DialogTitle,
  Select,
  MenuItem,
  Tooltip,
  Chip,
} from "@mui/material";
import { Edit as EditIcon, Link as LinkIcon, Delete as DeleteIcon } from "@mui/icons-material";
import { styled } from "@mui/material/styles";
import { markDownToHtml } from "../../lib/utils.js";
import axios from "axios";
import TagSelector from "./TagSelector.jsx";

const StyledCard = styled(Card)(({ theme }) => ({
  height: 150,
  maxWidth: "300px",
  width: "288px",
  display: "flex",
  flexDirection: "column",
  cursor: "pointer",
  transition: "box-shadow 0.3s ease-in-out",
  "&:hover": {
    boxShadow: "0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23)",
  },
}));

const TruncatedTypography = styled(Typography)({
  overflow: "hidden",
  textOverflow: "ellipsis",
  display: "-webkit-box",
  WebkitLineClamp: 3,
  WebkitBoxOrient: "vertical",
});

const modalStyle = {
  position: "absolute",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  width: 900,
  height: '80%',
  bgcolor: "background.paper",
  boxShadow: 24,
  p: 4,
  overflowY: "auto",
};

const DocumentCard = ({ document, onEdit, onDelete, isDeleting, versions }) => {
  const [editModalOpen, setEditModalOpen] = useState(false);
  const [viewModalOpen, setViewModalOpen] = useState(false);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [title, setTitle] = useState(document.title);
  const [prompt, setPrompt] = useState(document.prompt);
  const [isLoading, setIsLoading] = useState(false);
  const [selectedVersionIndex, setSelectedVersionIndex] = useState(0);
  const [availableTags, setAvailableTags] = useState([]);

  const parseTags = (tags) => {
    if (!tags) return [];
    try {
      const parsed = JSON.parse(tags);
      return Array.isArray(parsed) ? parsed : [];
    } catch (error) {
      console.error("Error parsing tags:", error);
      return [];
    }
  };

  const [selectedTags, setSelectedTags] = useState(parseTags(document.tags));

  useEffect(() => {
    fetchTags();
  }, []);

  const fetchTags = async () => {
    try {
      const response = await axios.get("/api/database-utility/tags");
      setAvailableTags(response.data);
    } catch (error) {
      console.error("Error fetching tags:", error);
    }
  };

  const allVersions = useMemo(() => {
    const uniqueVersions = [document, ...(versions || [])].reduce((acc, curr) => {
      if (!acc.find(v => v.version === curr.version)) {
        acc.push({...curr, parsedTags: parseTags(curr.tags)});
      }
      return acc;
    }, []);
    return uniqueVersions.sort((a, b) => b.version - a.version);
  }, [document, versions]);

  const handleEditClick = (e) => {
    e.stopPropagation();
    setEditModalOpen(true);
  };

  const handleEditSubmit = async () => {
    setIsLoading(true);
    try {
      const updatedDocument = await onEdit(document.id, { title, prompt, tags: JSON.stringify(selectedTags) });
      setTitle(updatedDocument.title);
      setPrompt(updatedDocument.prompt);
      setSelectedTags(parseTags(updatedDocument.tags));
      setEditModalOpen(false);
    } catch (error) {
      console.error("Error updating document:", error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleCardClick = () => {
    setViewModalOpen(true);
  };

  const handleDeleteClick = (e) => {
    e.stopPropagation();
    setDeleteDialogOpen(true);
  };

  const handleDeleteConfirm = async () => {
    try {
      await onDelete(document.id);
      setDeleteDialogOpen(false);
    } catch (error) {
      console.error("Error deleting document:", error);
    }
  };

  const handleVersionChange = (event) => {
    setSelectedVersionIndex(event.target.value);
  };

  const handleTagToggle = (tagType, name) => {
    setSelectedTags((prevTags) => {
      const tagExists = prevTags.some((t) => t.tagType === tagType && t.name === name);
      if (tagExists) {
        return prevTags.filter((t) => !(t.tagType === tagType && t.name === name));
      } else {
        return [...prevTags, { tagType, name }];
      }
    });
  };

  return (
    <>
      <StyledCard onClick={handleCardClick}>
        <CardContent>
          <Box
            display="flex"
            justifyContent="space-between"
            alignItems="center"
          >
            <Typography className="truncate" variant="h6" component="div" gutterBottom>
              {document.title}
            </Typography>
          </Box>
          <Box className="flex flex-nowrap gap-2 items-center">
            <IconButton
              component={Link}
              to={`/artifact/${document.id}`}
              onClick={(e) => e.stopPropagation()}
              size="small"
            >
              <LinkIcon fontSize='small' />
            </IconButton>
            <IconButton onClick={handleEditClick} size="small">
              <EditIcon fontSize='small'  />
            </IconButton>
            <IconButton 
              onClick={handleDeleteClick} 
              size="small" 
              disabled={isDeleting}
            >
              {isDeleting ? <CircularProgress size={24} /> : <DeleteIcon />}
            </IconButton>
          </Box>
          <TruncatedTypography variant="body2" color="text.secondary">
            {document.prompt}
          </TruncatedTypography>
          <Box sx={{ mt: 1, display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
            {selectedTags.map((tag) => (
              <Chip
                key={`${tag.tagType}:${tag.name}`}
                label={tag.name}
                size="small"
                sx={{
                  borderRadius: '4px',
                  fontSize: '0.6rem',
                  height: '18px',
                  '& .MuiChip-label': {
                    padding: '0 4px',
                  },
                }}
              />
            ))}
          </Box>
        </CardContent>
      </StyledCard>

      <Modal open={editModalOpen} onClose={() => setEditModalOpen(false)}>
        <Box sx={modalStyle}>
          <Typography variant="h6" component="h2" gutterBottom>
            Edit Document
          </Typography>
          <TextField
            fullWidth
            label="Title"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            margin="normal"
          />
          <TextField
            fullWidth
            label="Prompt"
            value={prompt}
            onChange={(e) => setPrompt(e.target.value)}
            margin="normal"
            multiline
            rows={4}
          />
          <TagSelector
            availableTags={availableTags}
            selectedTags={selectedTags}
            onTagToggle={handleTagToggle}
            editable={true}
          />
          <Box sx={{ mt: 2, display: "flex", justifyContent: "flex-end" }}>
            <Button onClick={() => setEditModalOpen(false)} sx={{ mr: 1 }}>
              Cancel
            </Button>
            <Button
              onClick={handleEditSubmit}
              variant="contained"
              disabled={isLoading}
            >
              {isLoading ? <CircularProgress size={24} /> : "Save"}
            </Button>
          </Box>
        </Box>
      </Modal>

      <Modal open={viewModalOpen} onClose={() => setViewModalOpen(false)}>
        <Box sx={modalStyle}>
          <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
            <Typography variant="h6" component="h2">
              {allVersions[selectedVersionIndex].title}
            </Typography>
            <Select
              value={selectedVersionIndex}
              onChange={handleVersionChange}
              size="small"
            >
              {allVersions.map((version, index) => (
                <MenuItem key={version.id || index} value={index}>
                  Version {version.version}
                  {index === 0 && " (Current)"}
                </MenuItem>
              ))}
            </Select>
          </Box>
          <Typography variant="body2" color="text.secondary" gutterBottom>
            Version: {allVersions[selectedVersionIndex].version}
          </Typography>
          <Typography variant="h6" gutterBottom sx={{ mt: 2 }}>
            Prompt:
          </Typography>
          <Typography variant="body1" paragraph>
            {allVersions[selectedVersionIndex].prompt}
          </Typography>
          <TagSelector
            availableTags={availableTags}
            selectedTags={allVersions[selectedVersionIndex].parsedTags}
            onTagToggle={() => {}}
            editable={false}
          />
          <Typography variant="h6" gutterBottom>
            Documentation:
          </Typography>
          <Box 
            dangerouslySetInnerHTML={{ __html: markDownToHtml(allVersions[selectedVersionIndex].documentation) }} 
            sx={{ 
              mt: 2, 
              '& img': { maxWidth: '100%', height: 'auto' },
              '& pre': { overflowX: 'auto', backgroundColor: '#f0f0f0', padding: '1em' },
              '& code': { fontFamily: 'monospace', backgroundColor: '#f0f0f0', padding: '0.2em 0.4em' },
            }}
          />
        </Box>
      </Modal>

      <Dialog
        open={deleteDialogOpen}
        onClose={() => setDeleteDialogOpen(false)}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
      >
        <DialogTitle id="alert-dialog-title">{"Delete Document"}</DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-description">
            Are you sure you want to delete this document? This action cannot be undone.
          </DialogContentText>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setDeleteDialogOpen(false)}>Cancel</Button>
          <Button onClick={handleDeleteConfirm} color="error" autoFocus disabled={isDeleting}>
            {isDeleting ? <CircularProgress size={24} /> : "Delete"}
          </Button>
        </DialogActions>
      </Dialog>
    </>
  );
};

export default DocumentCard;
<<< END ./client/src/components/_molecules/DocumentCard.jsx >>>

--- FILE: ./client/src/components/_molecules/TagSelector.jsx ---

<<< BEGIN ./client/src/components/_molecules/TagSelector.jsx >>>
import React from 'react';
import { Box, Typography, Chip } from '@mui/material';

const TagSelector = ({ availableTags, selectedTags, onTagToggle, editable = false }) => {
  const renderTags = (tagType) => (
    <Box sx={{ mt: 2, mb: 2 }}>
      <Typography variant="subtitle2" gutterBottom>
        {tagType === 'TopicTag' ? 'Topic Tags:' : 'Tags:'}
      </Typography>
      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
        {availableTags
          .filter(tag => tag.tagType === tagType)
          .map(tag => (
            <Chip
              key={`${tag.tagType}:${tag.name}`}
              label={tag.name}
              onClick={() => editable && onTagToggle(tag.tagType, tag.name)}
              color={selectedTags.some(t => t.tagType === tag.tagType && t.name === tag.name) ? 'primary' : 'default'}
              size="small"
              sx={{
                borderRadius: '4px',
                fontSize: '0.75rem',
                height: '24px',
                '& .MuiChip-label': {
                  padding: '0 8px',
                },
                cursor: editable ? 'pointer' : 'default',
              }}
            />
          ))}
      </Box>
    </Box>
  );

  return (
    <Box>
      {renderTags('Tag')}
      {renderTags('TopicTag')}
    </Box>
  );
};

export default TagSelector;
<<< END ./client/src/components/_molecules/TagSelector.jsx >>>

--- FILE: ./client/src/components/_organisms/AppHeader.jsx ---

<<< BEGIN ./client/src/components/_organisms/AppHeader.jsx >>>
import React from 'react';
import { AppBar, Toolbar, Typography, Box } from '@mui/material';
import { styled } from '@mui/material/styles';

const StyledAppBar = styled(AppBar)(({ theme }) => ({
  backgroundColor: theme.palette.primary.main,
  boxShadow: 'none',
  position: 'sticky',
  top: 0,
  zIndex: theme.zIndex.drawer + 1,
}));

const BrandTypography = styled(Typography)(({ theme }) => ({
  fontWeight: 700,
  letterSpacing: '0.1em',
  color: theme.palette.common.white,
  flexGrow: 1,
}));

const AppHeader = () => {
  return (
    <StyledAppBar>
      <Toolbar>
        <BrandTypography variant="h6" component="div">
          LATENT KNOWLEDGEBASE
        </BrandTypography>
      </Toolbar>
    </StyledAppBar>
  );
};

export default AppHeader;
<<< END ./client/src/components/_organisms/AppHeader.jsx >>>

--- FILE: ./client/src/components/_organisms/FactDisplay.jsx ---

<<< BEGIN ./client/src/components/_organisms/FactDisplay.jsx >>>
// File: ./client/src/components/FactDisplay.jsx

import React from "react";
import { Typography, Paper, Box } from "@mui/material";

function FactDisplay({ facts }) {
  return (
    <Box sx={{ mt: 2 }}>
      <Typography variant="h6" gutterBottom>
        Current Facts:
      </Typography>
      <Paper elevation={3} sx={{ p: 2, maxHeight: "400px", overflow: "auto" }}>
        <pre style={{ whiteSpace: "pre-wrap", wordBreak: "break-word" }}>
          {facts}
        </pre>
      </Paper>
    </Box>
  );
}

export default FactDisplay;

<<< END ./client/src/components/_organisms/FactDisplay.jsx >>>

--- FILE: ./client/src/components/_organisms/FactReviewModal.jsx ---

<<< BEGIN ./client/src/components/_organisms/FactReviewModal.jsx >>>
import React, { useState, useEffect } from "react";
import {
  Card,
  CardContent,
  Typography,
  IconButton,
  Box,
  Divider,
  Fab,
} from "@mui/material";
import CheckCircleIcon from "@mui/icons-material/CheckCircle";
import CancelIcon from "@mui/icons-material/Cancel";
import FactItem from "../_molecules/FactItem";

const buttonStyles = {
  height: "32px",
  fontSize: "0.8rem",
  padding: "0 8px",
};

const iconStyles = {
  fontSize: "1.2rem",
};

function FactReviewModal({ sustained, newFacts, conflicts, onComplete }) {
  const [reviewedFacts, setReviewedFacts] = useState({});

  useEffect(() => {
    const initialReview = {};
    [...newFacts, ...conflicts].forEach((fact) => {
      initialReview[fact.id] = null;
    });
    setReviewedFacts(initialReview);
  }, [newFacts, conflicts]);

  const handleFactReview = (id, isAccepted) => {
    setReviewedFacts((prev) => ({ ...prev, [id]: isAccepted }));
  };

  const handleBulkAction = (factType, isAccepted) => {
    setReviewedFacts((prev) => {
      const updated = { ...prev };
      if (factType === "new") {
        newFacts.forEach((fact) => {
          updated[fact.id] = isAccepted;
        });
      } else if (factType === "conflicts") {
        conflicts.forEach((conflict) => {
          updated[conflict.id] = isAccepted;
        });
      }
      return updated;
    });
  };

  const handleSubmit = () => {
    const finalReview = {
      sustained: sustained,
      new: newFacts.map((fact) => ({
        ...fact,
        accepted: reviewedFacts[fact.id],
      })),
      conflicts: conflicts.map((conflict) => ({
        ...conflict,
        accepted: reviewedFacts[conflict.id],
      })),
    };
    onComplete(finalReview);
  };

  const renderBulkActionButtons = (factType) => (
    <Box sx={{ display: "flex", justifyContent: "flex-end", mt: 2, gap: 1 }}>
      <Fab
        variant="extended"
        size="small"
        color="error"
        onClick={() => handleBulkAction(factType, false)}
        sx={{ ...buttonStyles, minWidth: "110px" }}
      >
        <CancelIcon sx={{ ...iconStyles, mr: 1 }} />
        Decline All
      </Fab>
      <Fab
        variant="extended"
        size="small"
        color="success"
        onClick={() => handleBulkAction(factType, true)}
        sx={{ ...buttonStyles, minWidth: "110px" }}
      >
        <CheckCircleIcon sx={{ ...iconStyles, mr: 1 }} />
        Accept All
      </Fab>
    </Box>
  );

  return (
    <Box className="fact-review-modal" sx={{ "& *": { fontSize: "0.9rem" } }}>
      <Typography variant="h6" sx={{ mb: 2, fontSize: "1.1rem" }}>
        Review New Facts
      </Typography>

      {newFacts.length > 0 && (
        <Card sx={{ mb: 2, bgcolor: "grey.50" }}>
          <CardContent sx={{ p: 1.5, "&:last-child": { pb: 1.5 } }}>
            <Typography variant="subtitle2" sx={{ mb: 1 }}>
              New Entries:
            </Typography>
            <Divider sx={{ my: 1 }} />
            {newFacts.map((fact) => (
              <FactItem
                key={fact.id}
                fact={fact}
                type="new"
                onReview={handleFactReview}
                reviewedStatus={reviewedFacts[fact.id]}
                buttonStyles={buttonStyles}
                iconStyles={iconStyles}
              />
            ))}
            {renderBulkActionButtons("new")}
          </CardContent>
        </Card>
      )}

      {conflicts.length > 0 && (
        <Card sx={{ mb: 2, bgcolor: "grey.50" }}>
          <CardContent sx={{ p: 1.5, "&:last-child": { pb: 1.5 } }}>
            <Typography variant="subtitle2" sx={{ mb: 1 }}>
              Conflicts:
            </Typography>
            <Divider sx={{ my: 1 }} />
            {conflicts.map((conflict) => (
              <FactItem
                key={conflict.id}
                fact={conflict}
                type="conflict"
                onReview={handleFactReview}
                reviewedStatus={reviewedFacts[conflict.id]}
                buttonStyles={buttonStyles}
                iconStyles={iconStyles}
              />
            ))}
            {renderBulkActionButtons("conflicts")}
          </CardContent>
        </Card>
      )}

      <Box
        sx={{
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          mt: 1,
        }}
      >
        <Typography
          variant="body2"
          color="text.secondary"
          sx={{ fontSize: "0.8rem" }}
        >
          {sustained.length} fact(s) unchanged
        </Typography>
        <IconButton
          onClick={handleSubmit}
          disabled={Object.values(reviewedFacts).some(
            (value) => value === null,
          )}
          color="primary"
          sx={{
            ...buttonStyles,
            bgcolor: "primary.main",
            color: "white",
            "&:hover": { bgcolor: "primary.dark" },
            "&:disabled": { bgcolor: "grey.300", color: "grey.500" },
          }}
        >
          <CheckCircleIcon sx={iconStyles} />
        </IconButton>
      </Box>
    </Box>
  );
}

export default FactReviewModal;

<<< END ./client/src/components/_organisms/FactReviewModal.jsx >>>

--- FILE: ./client/src/components/_organisms/Sidebar.jsx ---

<<< BEGIN ./client/src/components/_organisms/Sidebar.jsx >>>
import React, { useState } from 'react';
import { Link, useLocation } from 'react-router-dom';
import { 
  Drawer, 
  List, 
  ListItem, 
  ListItemIcon, 
  ListItemText, 
  Collapse, 
  Box,
  useTheme
} from '@mui/material';
import { 
  ExpandLess, 
  ExpandMore, 
  Home, 
  Description, 
  MenuBook, 
  Build,
  Inbox,
  CloudUpload,
  Code,
  AccountTree,
  Schema,
  Storage
} from '@mui/icons-material';
import LibraryBooksIcon from '@mui/icons-material/LibraryBooks';

const MenuItem = ({ item, level, location }) => {
  const [open, setOpen] = useState(true);
  const theme = useTheme();

  const handleClick = () => {
    setOpen(!open);
  };

  return (
    <>
      <ListItem 
        button 
        onClick={handleClick}
        sx={{ 
          pl: theme.spacing(2 + 2 * level),
          py: 0.5,
        }}
      >
        <ListItemIcon 
          sx={{ 
            color: theme.palette.text.primary,
            minWidth: 36,
            mr: 1,
          }}
        >
          {React.cloneElement(item.icon, { fontSize: 'small' })}
        </ListItemIcon>
        <ListItemText 
          primary={item.name} 
          primaryTypographyProps={{ variant: 'body2' }}
        />
        {item.subitems && (open ? <ExpandLess fontSize="small" /> : <ExpandMore fontSize="small" />)}
      </ListItem>
      {item.subitems && (
        <Collapse in={open} timeout="auto" unmountOnExit>
          <List component="div" disablePadding>
            {item.subitems.map((subitem, index) => (
              subitem.path ? (
                <ListItem
                  button
                  component={Link}
                  to={subitem.path}
                  key={index}
                  sx={{ 
                    pl: theme.spacing(4 + 2 * level),
                    py: 0.5,
                    bgcolor: location.pathname === subitem.path ? theme.palette.action.selected : 'transparent',
                    '&:hover': {
                      bgcolor: theme.palette.action.hover,
                    },
                  }}
                >
                  <ListItemIcon 
                    sx={{ 
                      color: theme.palette.text.primary,
                      minWidth: 36,
                      mr: 1,
                    }}
                  >
                    {React.cloneElement(subitem.icon, { fontSize: 'small' })}
                  </ListItemIcon>
                  <ListItemText 
                    primary={subitem.name} 
                    primaryTypographyProps={{ 
                      variant: 'body2',
                      color: subitem.style?.color || theme.palette.text.primary,
                    }}
                  />
                </ListItem>
              ) : (
                <ListItem
                  button
                  key={index}
                  sx={{ 
                    pl: theme.spacing(4 + 2 * level),
                    py: 0.5,
                    '&:hover': {
                      bgcolor: theme.palette.action.hover,
                    },
                  }}
                  disabled={!subitem.path}
                >
                  <ListItemIcon 
                    sx={{ 
                      color: theme.palette.text.primary,
                      minWidth: 36,
                      mr: 1,
                    }}
                  >
                    {React.cloneElement(subitem.icon, { fontSize: 'small' })}
                  </ListItemIcon>
                  <ListItemText 
                    primary={subitem.name} 
                    primaryTypographyProps={{ 
                      variant: 'body2',
                      color: subitem.style?.color || theme.palette.text.primary,
                    }}
                  />
                </ListItem>
              )
            ))}
          </List>
        </Collapse>
      )}
    </>
  );
};

const Sidebar = ({ open, drawerWidth }) => {
  const location = useLocation();
  const theme = useTheme();

  const menuItems = [
    {
      name: 'Home',
      icon: <Home />,
      subitems: [
        { name: 'Inbox', icon: <Inbox />, path: '/inbox' }
      ]
    },
    {
      name: 'Knowledge Base',
      icon: <MenuBook />,
      subitems: [
        { name: 'Fact Generator', icon: <Description />, path: '/' },
        { name: 'Artifact Builder', icon: <Description />, path: '/doc-builder' }
      ]
    },
    {
      name: 'Wiki',
      icon: <MenuBook />,
      subitems: [
        { name: 'Artifacts', icon: <LibraryBooksIcon /> ,path:'artifact' },
        { name: 'Code Explorer', icon: <Code /> ,path:'files' },
        { name: 'Tree View', icon: <AccountTree /> }
      ]
    },
    {
      name: 'Utilities',
      icon: <Build />,
      subitems: [
        { name: 'Repository Upload', icon: <CloudUpload />, path: '/repository-upload' },
        { name: 'Database Schema', icon: <Schema />, path: '/database-schema' },
        { name: 'Database Utility', icon: <Storage />, path: '/database-utility' }
      ]
    }
  ];

  return (
    <Drawer
      variant="persistent"
      anchor="left"
      open={open}
      sx={{
        width: drawerWidth,
        flexShrink: 0,
        '& .MuiDrawer-paper': {
          width: drawerWidth,
          boxSizing: 'border-box',
          bgcolor: 'background.paper',
          borderRight: `1px solid ${theme.palette.divider}`,
          mt: ['48px', '56px', '64px'],
        },
      }}
    >
      <Box sx={{ overflow: 'auto', py: 1 }}>
        <List>
          {menuItems.map((item, index) => (
            <MenuItem key={index} item={item} level={0} location={location} />
          ))}
        </List>
      </Box>
    </Drawer>
  );
};

export default Sidebar;
<<< END ./client/src/components/_organisms/Sidebar.jsx >>>

--- FILE: ./client/src/components/FilterBubbles.jsx ---

<<< BEGIN ./client/src/components/FilterBubbles.jsx >>>
// File: ./client/src/components/FilterBubbles.jsx

import React from 'react';
import { Box, Chip } from '@mui/material';

const FilterBubbles = ({ filters, selectedFilters, onFilterSelect }) => {
  return (
    <Box sx={{ mb: 2, display: 'flex', flexWrap: 'wrap', gap: 1 }}>
      {filters.map((filter) => (
        <Chip
          key={filter.name}
          label={`${filter.name} (${filter.count})`}
          onClick={() => onFilterSelect(filter)}
          color={selectedFilters.includes(filter) ? "primary" : "default"}
          variant={selectedFilters.includes(filter) ? "filled" : "outlined"}
          sx={{ 
            '&:hover': { 
              backgroundColor: (theme) => selectedFilters.includes(filter) 
                ? theme.palette.primary.dark 
                : theme.palette.action.hover 
            } 
          }}
        />
      ))}
    </Box>
  );
};

export default FilterBubbles;
<<< END ./client/src/components/FilterBubbles.jsx >>>

--- FILE: ./client/src/components/ResultsTable.jsx ---

<<< BEGIN ./client/src/components/ResultsTable.jsx >>>
// File: ./client/src/components/ResultsTable.jsx

import React from 'react';
import { 
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow, 
  Paper, 
  Typography 
} from '@mui/material';

const ResultsTable = ({ nodes }) => {
  if (nodes.length === 0) {
    return <Typography>No results found.</Typography>;
  }

  return (
    <TableContainer component={Paper}>
      <Table aria-label="results table">
        <TableHead>
          <TableRow>
            <TableCell>Name</TableCell>
            <TableCell>Type</TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {nodes.map((node, index) => (
            <TableRow key={index}>
              <TableCell>{node.name || 'unk'}</TableCell>
              <TableCell>{node.type || 'unk'}</TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  );
};

export default ResultsTable;
<<< END ./client/src/components/ResultsTable.jsx >>>

--- FILE: ./client/src/hooks/useActiveTab.js ---

<<< BEGIN ./client/src/hooks/useActiveTab.js >>>
import { useState, useEffect } from "react";

const useActiveTab = (initialTab) => {
  const [activeTab, setActiveTab] = useState(initialTab);

  useEffect(() => {
    console.log("App component loaded with activeTab:", activeTab);
  }, [activeTab]);

  return [activeTab, setActiveTab];
};

export default useActiveTab;

<<< END ./client/src/hooks/useActiveTab.js >>>

--- FILE: ./client/src/hooks/useFactService.js ---

<<< BEGIN ./client/src/hooks/useFactService.js >>>
import { useState } from "react";
import axios from "axios";
import logger from "../../../shared/logger.js";

const useFactService = () => {
  const [state, setState] = useState({
    distinctFacts: "",
    isLoading: false,
    notify: "",
    debugMessage: "",
    showFactReview: false,
    factsToReview: { sustained: [], new: [], conflicts: [] },
  });

  const setDistinctFacts = (facts) => {
    logger.data("useFactService: Setting distinctFacts", facts);
    setState((prev) => ({ ...prev, distinctFacts: facts || "" }));
  };

  const setIsLoading = (isLoading) => {
    logger.info(`useFactService: Setting isLoading to ${isLoading}`);
    setState((prev) => ({ ...prev, isLoading }));
  };

  const setDebugMessage = (message) => {
    logger.debug(`useFactService: Setting debug message: ${message}`);
    setState((prev) => ({ ...prev, debugMessage: message }));
  };

  const handleSubmit = async (input) => {
    setState((prev) => ({
      ...prev,
      isLoading: true,
      notify: "Processing facts...",
    }));
    try {
      logger.info(`API Request: POST /api/facts, Input: ${input}`);
      const { data } = await axios.post("/api/facts", { input });
      logger.info(
        `API Response: POST /api/facts, Data: ${JSON.stringify(data)}`,
      );

      setState((prev) => ({
        ...prev,
        factsToReview: data.result,
        showFactReview: true,
        isLoading: false,
        notify: "",
      }));
    } catch (error) {
      logger.error(`Error in handleSubmit: ${error.message}`);
      setState((prev) => ({
        ...prev,
        isLoading: false,
        notify: "Error processing facts. Please try again.",
        debugMessage: error.message,
      }));
    }
  };

  const handleFactReviewComplete = async (reviewedFacts) => {
    setState((prev) => ({
      ...prev,
      isLoading: true,
      notify: "Updating facts...",
      showFactReview: false,
    }));

    try {
      logger.info(
        `API Request: POST /api/facts/finalize, ReviewedFacts: ${JSON.stringify(reviewedFacts)}`,
      );
      const { data } = await axios.post("/api/facts/finalize", {
        reviewedFacts,
      });
      logger.info(
        `API Response: POST /api/facts/finalize, Data: ${JSON.stringify(data)}`,
      );

      setState((prev) => ({
        ...prev,
        distinctFacts: data.facts,
        isLoading: false,
        notify: "Facts updated successfully!",
      }));

      setTimeout(() => setState((prev) => ({ ...prev, notify: "" })), 3000);
    } catch (error) {
      logger.error(`Error in handleFactReviewComplete: ${error.message}`);
      setState((prev) => ({
        ...prev,
        isLoading: false,
        notify: "Error updating facts. Please try again.",
        debugMessage: error.message,
      }));
    }
  };

  return {
    ...state,
    setDistinctFacts,
    setIsLoading,
    setDebugMessage,
    setNotify: (message) => setState((prev) => ({ ...prev, notify: message })),
    handleSubmit,
    handleFactReviewComplete,
  };
};

export default useFactService;

<<< END ./client/src/hooks/useFactService.js >>>

--- FILE: ./client/src/index.jsx ---

<<< BEGIN ./client/src/index.jsx >>>
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);

<<< END ./client/src/index.jsx >>>

--- FILE: ./client/src/pages/DatabaseSchemaPage.jsx ---

<<< BEGIN ./client/src/pages/DatabaseSchemaPage.jsx >>>
import React from 'react';
import DatabaseSchema from '../components/DatabaseSchema/DatabaseSchema';

const DatabaseSchemaPage = ({ setNotify }) => {
  return <DatabaseSchema setNotify={setNotify} />;
};

export default DatabaseSchemaPage;
<<< END ./client/src/pages/DatabaseSchemaPage.jsx >>>

--- FILE: ./client/src/pages/DocBuilderPage.jsx ---

<<< BEGIN ./client/src/pages/DocBuilderPage.jsx >>>
import React from 'react';
import DocBuilder from '../components/DocBuilder/DocBuilder';

const DocBuilderPage = ({ setNotify }) => {
  return <DocBuilder setNotify={setNotify} />;
};

export default DocBuilderPage;
<<< END ./client/src/pages/DocBuilderPage.jsx >>>

--- FILE: ./client/src/pages/DocumentationPage.jsx ---

<<< BEGIN ./client/src/pages/DocumentationPage.jsx >>>
import React from 'react';
import Documentation from '../components/Documentation/Documentation';

const DocumentationPage = ({ setNotify }) => {
  return <Documentation setNotify={setNotify} />;
};

export default DocumentationPage;
<<< END ./client/src/pages/DocumentationPage.jsx >>>

--- FILE: ./client/src/pages/InboxPage.jsx ---

<<< BEGIN ./client/src/pages/InboxPage.jsx >>>
import React from 'react';
import Inbox from '../components/Inbox/Inbox';

const InboxPage = () => {
  return <Inbox />;
};

export default InboxPage;
<<< END ./client/src/pages/InboxPage.jsx >>>

--- FILE: ./client/src/pages/RepositoryUploadPage.jsx ---

<<< BEGIN ./client/src/pages/RepositoryUploadPage.jsx >>>
import React from 'react';
import RepositoryUpload from '../components/RepositoryUpload/RepositoryUpload';

const RepositoryUploadPage = ({ setIsLoading, setNotify, setDebugMessage }) => {
  return (
    <RepositoryUpload
      setIsLoading={setIsLoading}
      setNotify={setNotify}
      setDebugMessage={setDebugMessage}
    />
  );
};

export default RepositoryUploadPage;
<<< END ./client/src/pages/RepositoryUploadPage.jsx >>>

--- FILE: ./client/src/pages/FactGeneratorPage.jsx ---

<<< BEGIN ./client/src/pages/FactGeneratorPage.jsx >>>
import React, { useState } from 'react';
import FactGenerator from '../components/FactGenerator/FactGenerator';
import useFactService from '../hooks/useFactService';

const FactGeneratorPage = () => {
  const [inputText, setInputText] = useState('');
  const {
    distinctFacts,
    setDistinctFacts,
    isLoading,
    setIsLoading,
    showFactReview,
    factsToReview,
    handleSubmit,
    handleFactReviewComplete,
    setDebugMessage,
  } = useFactService();

  const handleInputSubmit = (text) => {
    if (text && typeof text === 'string' && text.trim()) {
      handleSubmit(text);
      setInputText('');
    }
  };

  return (
    <FactGenerator
      inputText={inputText}
      setInputText={setInputText}
      distinctFacts={distinctFacts}
      setDistinctFacts={setDistinctFacts}
      isLoading={isLoading}
      setIsLoading={setIsLoading}
      showFactReview={showFactReview}
      factsToReview={factsToReview}
      handleSubmit={handleInputSubmit}
      handleFactReviewComplete={handleFactReviewComplete}
      setDebugMessage={setDebugMessage}
    />
  );
};

export default FactGeneratorPage;
<<< END ./client/src/pages/FactGeneratorPage.jsx >>>

--- FILE: ./client/src/pages/DatabaseUtilityPage.jsx ---

<<< BEGIN ./client/src/pages/DatabaseUtilityPage.jsx >>>
// File: ./client/src/pages/DatabaseUtilityPage.jsx

import React, { useState, useEffect } from 'react';
import { Box, Typography } from '@mui/material';
import axios from 'axios';
import FilterBubbles from '../components/FilterBubbles';
import ResultsTable from '../components/ResultsTable';

const DatabaseUtilityPage = ({ setNotify }) => {
  const [filters, setFilters] = useState([]);
  const [selectedFilters, setSelectedFilters] = useState([]);
  const [results, setResults] = useState([]);

  useEffect(() => {
    fetchFilters();
  }, []);

  const fetchFilters = async () => {
    try {
      const response = await axios.get('/api/database-utility/filters');
      setFilters(response.data);
    } catch (error) {
      console.error('Error fetching filters:', error);
      setNotify('Error fetching filters. Please try again.');
    }
  };

  const handleFilterSelect = async (filter) => {
    const updatedFilters = selectedFilters.includes(filter)
      ? selectedFilters.filter(f => f !== filter)
      : [...selectedFilters, filter];

    setSelectedFilters(updatedFilters);

    try {
      const response = await axios.post('/api/database-utility/apply-filters', { filters: updatedFilters });
      setResults(response.data.results);
      setFilters(response.data.updatedFilters);
    } catch (error) {
      console.error('Error applying filters:', error);
      setNotify('Error applying filters. Please try again.');
    }
  };

  return (
    <Box sx={{ width: '100%', maxWidth: 1200, mx: 'auto', mt: 4 }}>
      <Typography variant="h4" gutterBottom>
        Database Explorer
      </Typography>
      <FilterBubbles
        filters={filters}
        selectedFilters={selectedFilters}
        onFilterSelect={handleFilterSelect}
      />
      <ResultsTable nodes={results} />
    </Box>
  );
  };

export default DatabaseUtilityPage;
<<< END ./client/src/pages/DatabaseUtilityPage.jsx >>>

--- FILE: ./client/src/pages/FilesPage.jsx ---

<<< BEGIN ./client/src/pages/FilesPage.jsx >>>
import React, { useState, useEffect } from "react";
import axios from "axios";
import {
  Box,
  Typography,
  Button,
  TextField,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Paper,
  List,
} from "@mui/material";
import { Refresh as RefreshIcon } from "@mui/icons-material";
import FileTreeItem from "../components/_molecules/FileTreeItem"; 

const FilesPage = () => {
  const [files, setFiles] = useState(null);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState("");
  const [error, setError] = useState(null);

  useEffect(() => {
    fetchFiles();
  }, []);

  const fetchFiles = async () => {
    setLoading(true);
    setError(null);
    try {
      const response = await axios.get("/api/repository/files", {
        headers: {
          "Content-Type": "application/json",
        },
      });
      if (response.data && response.data.fileTree) {
        setFiles(response.data.fileTree);
      } else {
        throw new Error("Unexpected data structure received from the server");
      }
    } catch (error) {
      console.error("Error fetching files:", error);
      setError(
        error.response?.data?.message ||
          "Failed to fetch files. Please try again."
      );
    } finally {
      setLoading(false);
    }
  };

  return (
    <Box sx={{ p: 3, maxWidth: 1200, margin: "0 auto", width: "100%" }}>
      <Box
        sx={{
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          mb: 3,
        }}
      >
        <Typography variant="h4" component="h1">
          Files
        </Typography>
        <Button
          variant="contained"
          startIcon={<RefreshIcon />}
          onClick={fetchFiles}
          disabled={loading}
        >
          Refresh
        </Button>
      </Box>

      <Box sx={{ display: "flex", gap: 2, mb: 3 }}>
        <TextField
          label="Search files"
          variant="outlined"
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          sx={{ flexGrow: 1 }}
        />
        <FormControl sx={{ minWidth: 120 }}>
          <InputLabel>Filter</InputLabel>
          <Select value="" label="Filter">
            <MenuItem value="">None</MenuItem>
          </Select>
        </FormControl>
      </Box>

      {error && (
        <Typography color="error" sx={{ mb: 2 }}>
          {error}
        </Typography>
      )}

      <Paper className="px-4 py-2"  elevation={3} sx={{ maxHeight: "80vh", overflow: "auto" }}>
        <List>
          {loading ? (
            <Typography sx={{ p: 2 }}>Loading...</Typography>
          ) : files ? (
            <FileTreeItem item={files} searchTerm={searchTerm} />
          ) : (
            <Typography sx={{ p: 2 }}>No files found</Typography>
          )}
        </List>
      </Paper>
    </Box>
  );
};

export default FilesPage;
<<< END ./client/src/pages/FilesPage.jsx >>>

--- FILE: ./client/src/pages/FilterPage.jsx ---

<<< BEGIN ./client/src/pages/FilterPage.jsx >>>
// File: ./client/src/pages/FilterPage.jsx

import React from 'react';
import CloudFuzzyFilter from '../components/CloudFuzzyFilter/CloudFuzzyFilter';

const FilterPage = ({ setNotify }) => {
  return (
    <CloudFuzzyFilter setNotify={setNotify} />
  );
};

export default FilterPage;
<<< END ./client/src/pages/FilterPage.jsx >>>

--- FILE: ./client/src/pages/Artifact.jsx ---

<<< BEGIN ./client/src/pages/Artifact.jsx >>>
import React, { useState, useEffect } from "react";
import { useParams, useNavigate } from "react-router-dom";
import axios from "axios";
import {
  Box,
  Typography,
  CircularProgress,
  Paper,
  Divider,
  Button,
  Dialog,
  DialogActions,
  DialogContent,
  DialogContentText,
  DialogTitle,
  TextField,
  Chip,
  Tooltip,
} from "@mui/material";
import { Delete as DeleteIcon, Edit as EditIcon, Save as SaveIcon, ArrowBack as ArrowBackIcon } from "@mui/icons-material";
import { markDownToHtml } from "../lib/utils";
import TagSelector from "../components/_molecules/TagSelector";

const ArtifactPage = () => {
  const { id } = useParams();
  const navigate = useNavigate();
  const [versions, setVersions] = useState([]);
  const [selectedVersionIndex, setSelectedVersionIndex] = useState(0);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [openDeleteDialog, setOpenDeleteDialog] = useState(false);
  const [editMode, setEditMode] = useState(false);
  const [editedPrompt, setEditedPrompt] = useState("");
  const [availableTags, setAvailableTags] = useState([]);
  const [selectedTags, setSelectedTags] = useState([]);

  useEffect(() => {
    fetchDocument();
    fetchTags();
  }, [id]);

  const parseTags = (tags) => {
    if (!tags) return [];
    try {
      const parsed = JSON.parse(tags);
      return Array.isArray(parsed) ? parsed : [];
    } catch (error) {
      console.error("Error parsing tags:", error);
      return [];
    }
  };

  const fetchDocument = async () => {
    try {
      setLoading(true);
      const response = await axios.get(`/api/documents/${id}`);
      const { document, versions } = response.data;
      setVersions([document, ...versions]);
      setEditedPrompt(document.prompt);
      setSelectedTags(parseTags(document.tags));
      setLoading(false);
    } catch (err) {
      console.error("Error fetching document:", err);
      setError("Failed to fetch the document. Please try again later.");
      setLoading(false);
    }
  };

  const fetchTags = async () => {
    try {
      const response = await axios.get("/api/database-utility/tags");
      setAvailableTags(response.data);
    } catch (error) {
      console.error("Error fetching tags:", error);
    }
  };

  const handleVersionSelect = (index) => {
    setSelectedVersionIndex(index);
    setEditedPrompt(versions[index].prompt);
    setSelectedTags(parseTags(versions[index].tags));
    setEditMode(false);
  };

  const handleDelete = async () => {
    try {
      await axios.delete(`/api/documents/${id}`);
      setOpenDeleteDialog(false);
      navigate("/artifact", { replace: true });
    } catch (err) {
      console.error("Error deleting document:", err);
      setError("Failed to delete the document. Please try again later.");
    }
  };

  const handleUpdate = async () => {
    try {
      setLoading(true);
      await axios.put(`/api/documents/${id}`, {
        ...versions[selectedVersionIndex],
        prompt: editedPrompt,
        tags: JSON.stringify(selectedTags),
      });
      await fetchDocument();
      setEditMode(false);
    } catch (err) {
      console.error("Error updating document:", err);
      setError("Failed to update the document. Please try again later.");
    } finally {
      setLoading(false);
    }
  };

  const handleBack = () => {
    navigate(-1);
  };

  const handleTagToggle = (tagType, name) => {
    setSelectedTags((prevTags) => {
      const tagExists = prevTags.some((t) => t.tagType === tagType && t.name === name);
      if (tagExists) {
        return prevTags.filter((t) => !(t.tagType === tagType && t.name === name));
      } else {
        return [...prevTags, { tagType, name }];
      }
    });
  };

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" minHeight="80vh">
        <CircularProgress />
      </Box>
    );
  }

  if (error) {
    return (
      <Box textAlign="center" mt={4}>
        <Typography color="error">{error}</Typography>
      </Box>
    );
  }

  if (versions.length === 0) {
    return (
      <Box textAlign="center" mt={4}>
        <Typography>Document not found.</Typography>
      </Box>
    );
  }

  const selectedVersion = versions[selectedVersionIndex];

  return (
    <Box sx={{ maxWidth: 1200, p: 3 }}>
      <Button
        variant="outlined"
        startIcon={<ArrowBackIcon />}
        onClick={handleBack}
        sx={{ mb: 2 }}
      >
        Back
      </Button>
      <Paper elevation={3} sx={{ p: 3 }}>
        <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
          <Typography variant="h4" component="h1">
            {selectedVersion.title}
          </Typography>
          <Box>
            <Button
              variant="contained"
              color="primary"
              startIcon={editMode ? <SaveIcon /> : <EditIcon />}
              onClick={() => editMode ? handleUpdate() : setEditMode(true)}
              sx={{ mr: 1 }}
              disabled={selectedVersionIndex !== 0}
            >
              {editMode ? "Save" : "Edit"}
            </Button>
            <Button
              variant="contained"
              color="error"
              startIcon={<DeleteIcon />}
              onClick={() => setOpenDeleteDialog(true)}
              disabled={selectedVersionIndex !== 0}
            >
              Delete
            </Button>
          </Box>
        </Box>

        <Box sx={{ mb: 2, display: 'flex', flexWrap: 'wrap', gap: 1 }}>
          {versions.map((version, index) => (
            <Tooltip
              key={version.id || index}
              title={index === 0 ? "Latest Version" : ""}
              arrow
            >
              <Chip
                label={`Version ${versions.length - index}`}
                onClick={() => handleVersionSelect(index)}
                color={selectedVersionIndex === index ? "primary" : "default"}
                variant={selectedVersionIndex === index ? "filled" : "outlined"}
              />
            </Tooltip>
          ))}
        </Box>

        <Typography variant="h6" gutterBottom sx={{ mt: 2 }}>
          Prompt:
        </Typography>
        {editMode ? (
          <TextField
            fullWidth
            multiline
            rows={4}
            value={editedPrompt}
            onChange={(e) => setEditedPrompt(e.target.value)}
            variant="outlined"
            sx={{ mb: 2 }}
          />
        ) : (
          <Typography paragraph>{selectedVersion.prompt}</Typography>
        )}

        <TagSelector
          availableTags={availableTags}
          selectedTags={selectedTags}
          onTagToggle={handleTagToggle}
          editable={editMode}
        />

        <Divider sx={{ my: 3 }} />
        <Box
          className="markdown-content w-full"
          dangerouslySetInnerHTML={{
            __html: markDownToHtml(selectedVersion.documentation),
          }}
          sx={{
            "& h1, & h2, & h3, & h4, & h5, & h6": {
              mt: 2,
              mb: 1,
            },
            "& p": {
              mb: 2,
            },
            "& ul, & ol": {
              mb: 2,
              pl: 4,
            },
            "& code": {
              backgroundColor: "grey.100",
              p: 0.5,
              borderRadius: 1,
            },
            "& pre": {
              backgroundColor: "grey.100",
              p: 2,
              borderRadius: 2,
              overflowX: "auto",
            },
            "& a": {
              m: 0.5,
              borderRadius: 1.5,
              textDecoration: "none",
              cursor: "pointer"
            },
          }}
        />
      </Paper>

      <Dialog
        open={openDeleteDialog}
        onClose={() => setOpenDeleteDialog(false)}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
      >
        <DialogTitle id="alert-dialog-title">{"Delete Document"}</DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-description">
            Are you sure you want to delete this document? This action cannot be undone.
          </DialogContentText>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setOpenDeleteDialog(false)}>Cancel</Button>
          <Button onClick={handleDelete} color="error" autoFocus>
            Delete
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default ArtifactPage;
<<< END ./client/src/pages/Artifact.jsx >>>

--- FILE: ./client/src/pages/Artifacts.jsx ---

<<< BEGIN ./client/src/pages/Artifacts.jsx >>>
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import axios from 'axios';
import { 
  Box, 
  Typography, 
  Grid, 
  Card, 
  CardContent, 
  CardActionArea,
  CircularProgress
} from '@mui/material';

const ArtifactsPage = () => {
  const [documents, setDocuments] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const navigate = useNavigate();

  useEffect(() => {
    fetchDocuments();
  }, []);

  const fetchDocuments = async () => {
    try {
      setLoading(true);
      const response = await axios.get('/api/documents');
      setDocuments(response.data);
      setLoading(false);
    } catch (err) {
      console.error('Error fetching documents:', err);
      setError('Failed to fetch documents. Please try again later.');
      setLoading(false);
    }
  };

  const handleCardClick = (id) => {
    navigate(`/artifact/${id}`);
  };

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" minHeight="80vh">
        <CircularProgress />
      </Box>
    );
  }

  if (error) {
    return (
      <Box textAlign="center" mt={4}>
        <Typography color="error">{error}</Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ maxWidth: 1200, margin: '0 auto', p: 3 }}>
      <Typography variant="h4" component="h1" gutterBottom>
        Artifacts
      </Typography>
      <Grid container spacing={3}>
        {documents.map((doc) => (
          <Grid item xs={12} sm={6} md={4} key={doc.document.id}>
            <Card sx={{ height: '100%' }}>
              <CardActionArea onClick={() => handleCardClick(doc.document.id)} sx={{ height: '100%' }}>
                <CardContent>
                  <div className='w-full flex justify-between items-center'>
                    <Typography variant="h6" component="h2" gutterBottom>
                      {doc.document.title}
                    </Typography>
                  </div>
                 
                  <Typography variant="body2" color="text.secondary">
                    ID: {doc.document.id}
                  </Typography>
                  <Typography variant="body2" sx={{ mt: 1, overflow: 'hidden', textOverflow: 'ellipsis', display: '-webkit-box', WebkitLineClamp: 3, WebkitBoxOrient: 'vertical' }}>
                    {doc.document.prompt}
                  </Typography>
                </CardContent>
              </CardActionArea>
            </Card>
          </Grid>
        ))}
      </Grid>
    </Box>
  );
};

export default ArtifactsPage;
<<< END ./client/src/pages/Artifacts.jsx >>>

--- FILE: ./client/src/pages/FilePage.jsx ---

<<< BEGIN ./client/src/pages/FilePage.jsx >>>
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate, Link } from 'react-router-dom';
import axios from 'axios';
import {
  Box,
  Typography,
  Paper,
  Button,
  CircularProgress,
  Card,
  CardContent,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  Divider,
} from '@mui/material';
import { ArrowBack as ArrowBackIcon, InsertDriveFile as FileIcon } from '@mui/icons-material';
import MermaidDiagram from '../components/_atoms/MermaidDiagram';

const FilePage = () => {
  const { name } = useParams();
  const navigate = useNavigate();
  const [fileDetails, setFileDetails] = useState(null);
  const [relatedFiles, setRelatedFiles] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetchFileDetails();
  }, [name]);

  const fetchFileDetails = async () => {
    setLoading(true);
    try {
      const response = await axios.get(`/api/repository/file/${encodeURIComponent(name)}`);
      setFileDetails(response.data.documentation);
      setRelatedFiles(response.data.relatedFiles || []);
      setError(null);
    } catch (error) {
      console.error('Error fetching file details:', error);
      setError('Failed to load file details. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const formatDate = (dateObj) => {
    if (!dateObj || !dateObj.year) return 'N/A';
    const { year, month, day, hour, minute, second } = dateObj;
    const date = new Date(year.low, month.low - 1, day.low, hour.low, minute.low, second.low);
    return date.toLocaleString();
  };

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
      </Box>
    );
  }

  if (error) {
    return (
      <Box sx={{ p: 3, maxWidth: 800, margin: '0', width:'100%' }}>
        <Typography color="error">{error}</Typography>
        <Button startIcon={<ArrowBackIcon />} onClick={() => navigate(-1)} sx={{ mt: 2 }}>
          Go Back
        </Button>
      </Box>
    );
  }

  return (
    <Box sx={{ p: 3, maxWidth: 1200, margin: '0 auto' }}>
      <Button startIcon={<ArrowBackIcon />} onClick={() => navigate(-1)} sx={{ mb: 3 }}>
        Back
      </Button>

      <Box sx={{ display: 'flex', gap: 3, flexWrap: 'wrap' }}>
        <Paper elevation={3} sx={{ p: 3, flexGrow: 1, minWidth: '60%' }}>
          <Typography variant="h4" component="h1" gutterBottom>
            {fileDetails?.file_name || 'File Details'}
          </Typography>

          <Typography variant="body1" paragraph>
            <strong>Path:</strong> {fileDetails?.file_path}
          </Typography>

          <Typography variant="body1" paragraph>
            <strong>Size:</strong> {fileDetails?.file_size} bytes
          </Typography>

          <Typography variant="body1" paragraph>
            <strong>Last Modified:</strong> {formatDate(fileDetails?.modified_at)}
          </Typography>

          <Typography variant="h6" gutterBottom sx={{ mt: 4 }}>
            Documentation
          </Typography>
          <Typography variant="body1" paragraph>
            {fileDetails?.documentation || 'No documentation available.'}
          </Typography>

          {fileDetails?.mermaid_diagram && (
            <>
              <Typography variant="h6" gutterBottom sx={{ mt: 4 }}>
                Mermaid Diagram
              </Typography>
              <Box sx={{ mt: 2, mb: 2, maxWidth: '100%', overflow: 'auto' }}>
                <MermaidDiagram diagram={fileDetails.mermaid_diagram} />
              </Box>
            </>
          )}
        </Paper>

        {relatedFiles.length > 0 && (
          <Card sx={{ maxWidth: "1200px", width:'100%', alignSelf: 'flex-start' }}>
            <CardContent>
              <Typography variant="h6" gutterBottom>
                Related Files
              </Typography>
              <List>
                {relatedFiles.map((file, index) => (
                  <React.Fragment key={file.file_path}>
                    {index > 0 && <Divider />}
                    <ListItem 
                      button 
                      component={Link} 
                      to={`/file/${encodeURIComponent(file.file_path)}`}
                      sx={{ py: 1 }}
                    >
                      <ListItemIcon>
                        <FileIcon />
                      </ListItemIcon>
                      <ListItemText 
                        primary={file.file_name} 
                        secondary={file.file_path.split('/').slice(-2).join('/')}
                        primaryTypographyProps={{ variant: 'body2' }}
                        secondaryTypographyProps={{ variant: 'caption' }}
                      />
                    </ListItem>
                  </React.Fragment>
                ))}
              </List>
            </CardContent>
          </Card>
        )}
      </Box>
    </Box>
  );
};

export default FilePage;
<<< END ./client/src/pages/FilePage.jsx >>>

--- FILE: ./client/src/App.css ---

<<< BEGIN ./client/src/App.css >>>
@tailwind base;
@tailwind components;
@tailwind utilities;
.markdown-content {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen",
    "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue",
    sans-serif;
  line-height: 1.6;
  color: #333;
}

.markdown-content h1,
.markdown-content h2,
.markdown-content h3,
.markdown-content h4,
.markdown-content h5,
.markdown-content h6 {
  margin-top: 24px;
  margin-bottom: 16px;
  font-weight: 600;
  line-height: 1.25;
}

.markdown-content h1 {
  font-size: 2em;
}
.markdown-content h2 {
  font-size: 1.5em;
}
.markdown-content h3 {
  font-size: 1.25em;
}
.markdown-content h4 {
  font-size: 1em;
}
.markdown-content h5 {
  font-size: 0.875em;
}
.markdown-content h6 {
  font-size: 0.85em;
}

.markdown-content p {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-content a {
  color: #0366d6;
  text-decoration: none;
}

.markdown-content a:hover {
  text-decoration: underline;
}

.markdown-content code {
  padding: 0.2em 0.4em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(27, 31, 35, 0.05);
  border-radius: 3px;
}

.markdown-content pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f6f8fa;
  border-radius: 3px;
}

.markdown-content blockquote {
  padding: 0 1em;
  color: #6a737d;
  border-left: 0.25em solid #dfe2e5;
  margin: 0 0 16px 0;
}

.markdown-content ul,
.markdown-content ol {
  padding-left: 2em;
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-content img {
  max-width: 100%;
  box-sizing: content-box;
}

<<< END ./client/src/App.css >>>

--- FILE: ./client/src/lib/utils.js ---

<<< BEGIN ./client/src/lib/utils.js >>>
import { clsx} from "clsx"
import { twMerge } from "tailwind-merge"
import showdown from "showdown"

export function cn(...inputs) {
  return twMerge(clsx(inputs))
}

export function serializeDiagram(diagram) {
  // Trim leading/trailing whitespace
  let trimmed = diagram.trim();

  // Normalize newlines (in case of mixed line endings)
  let normalizedNewlines = trimmed.replace(/\r\n|\r|\n/g, '\n');

  // Determine if it's a class diagram
  const isClassDiagram = normalizedNewlines.startsWith('classDiagram');

  if (isClassDiagram) {
    // For class diagrams, we want to keep double quotes
    // Just remove any extra spaces at the start of lines and compress multiple spaces
    return normalizedNewlines.replace(/^ +/gm, '').replace(/ +/g, ' ');
  } else {
    // For other diagrams (like flowcharts), replace double quotes with single quotes
    return normalizedNewlines
      .replace(/"/g, "'")
      .replace(/^ +/gm, '')
      .replace(/ +/g, ' ');
  }
}

export const markDownToHtml = (markDown)=>{
  const converter = new showdown.Converter();
  const html = converter.makeHtml(markDown);
  return html;
}


<<< END ./client/src/lib/utils.js >>>

--- FILE: ./client/src/theme.js ---

<<< BEGIN ./client/src/theme.js >>>
// File: ./client/src/theme.js

import { createTheme } from "@mui/material/styles";

const getTheme = (mode) => createTheme({
  palette: {
    mode,
    primary: {
      main: mode === 'light' ? "#1e3145" : "#4a5b72",
      light: mode === 'light' ? "#4a5b72" : "#6c7c93",
      dark: mode === 'light' ? "#162233" : "#344b61",
      contrastText: "#fff",
    },
    secondary: {
      main: mode === 'light' ? "#f5f5f5" : "#333333",
      light: mode === 'light' ? "#ffffff" : "#4d4d4d",
      dark: mode === 'light' ? "#e0e0e0" : "#1a1a1a",
      contrastText: mode === 'light' ? "#000" : "#fff",
    },
    background: {
      default: mode === 'light' ? "#ffffff" : "#121212",
      paper: mode === 'light' ? "#f5f5f5" : "#1e1e1e",
    },
  },
  typography: {
    fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
    h1: {
      fontSize: "2.5rem",
      fontWeight: 500,
    },
    h2: {
      fontSize: "2rem",
      fontWeight: 500,
    },
    h3: {
      fontSize: "1.75rem",
      fontWeight: 500,
    },
    h4: {
      fontSize: "1.5rem",
      fontWeight: 500,
    },
    h5: {
      fontSize: "1.25rem",
      fontWeight: 500,
    },
    h6: {
      fontSize: "1rem",
      fontWeight: 500,
    },
  },
  components: {
    MuiAppBar: {
      styleOverrides: {
        root: {
          backgroundColor: mode === 'light' ? "#1e3145" : "#2c3e50",
        },
      },
    },
    MuiDrawer: {
      styleOverrides: {
        paper: {
          backgroundColor: mode === 'light' ? "#ffffff" : "#1e1e1e",
          borderRight: `1px solid ${mode === 'light' ? "#e0e0e0" : "#333333"}`,
        },
      },
    },
    MuiChip: {
      styleOverrides: {
        root: {
          borderRadius: '16px',
          '&:hover': {
            boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',
          },
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          transition: 'box-shadow 0.3s ease-in-out',
          '&:hover': {
            boxShadow: '0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23)',
          },
        },
      },
    },
  },
});

export default getTheme;
<<< END ./client/src/theme.js >>>

--- FILE: ./client/src/App.jsx ---

<<< BEGIN ./client/src/App.jsx >>>
// File: client/src/App.jsx

import React, { useState, useMemo } from "react";
import { ThemeProvider } from "@mui/material/styles";
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import { Box, CssBaseline } from "@mui/material";
import Notification from "./components/_atoms/Notification";
import Loader from "./components/_atoms/Loader";
import Layout from "./components/Layouts/Layout";
import FactGeneratorPage from "./pages/FactGeneratorPage";
import DocumentationPage from "./pages/DocumentationPage";
import RepositoryUploadPage from "./pages/RepositoryUploadPage";
import DocBuilderPage from "./pages/DocBuilderPage";
import DatabaseSchemaPage from "./pages/DatabaseSchemaPage";
import DatabaseUtilityPage from "./pages/DatabaseUtilityPage";
import InboxPage from "./pages/InboxPage";
import FilePage from "./pages/FilePage";
import FilesPage from "./pages/FilesPage";
import useFactService from "./hooks/useFactService";
import getTheme from "./theme";

import "./App.css";
import ArtifactPage from "./pages/Artifact";
import ArtifactsPage from "./pages/Artifacts";

function App() {
  const [mode, setMode] = useState(() => {
    return localStorage.getItem('lastMode') || 'light';
  });
  const theme = useMemo(() => getTheme(mode), [mode]);
  const {
    isLoading,
    notify,
    debugMessage,
    setDebugMessage,
    setNotify,
    setIsLoading
  } = useFactService();

  const toggleTheme = () => {
    const newMode = mode === 'light' ? 'dark' : 'light';
    setMode(newMode);
    localStorage.setItem('lastMode', newMode);
  };

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <Router>
        <Layout toggleTheme={toggleTheme} mode={mode}>
          <Box
            sx={{
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              maxWidth: "1200px",
              margin: "0 auto",
            }}
          >
            <Routes>
              <Route path="/" element={<FactGeneratorPage />} />
              <Route path="/files" element={<FilesPage />} />
               <Route path="/artifact" element={<ArtifactsPage />} />
               <Route path="/artifact/:id" element={<ArtifactPage />} />
              <Route path="/documentation" element={<DocumentationPage setNotify={setNotify} />} />
              <Route 
                path="/repository-upload" 
                element={
                  <RepositoryUploadPage 
                    setIsLoading={setIsLoading} 
                    setNotify={setNotify} 
                    setDebugMessage={setDebugMessage} 
                  />
                } 
              />
              <Route path="/doc-builder" element={<DocBuilderPage setNotify={setNotify} />} />
              <Route path="/database-schema" element={<DatabaseSchemaPage setNotify={setNotify} />} />
              <Route path="/database-utility" element={<DatabaseUtilityPage setNotify={setNotify} />} />
              <Route path="/inbox" element={<InboxPage />} />
              <Route path="/file/:name" element={<FilePage />} />
            </Routes>
            <Loader isLoading={isLoading} />
            <Notification
              message={notify || debugMessage}
              clearMessage={() => setDebugMessage("")}
            />
          </Box>
        </Layout>
      </Router>
    </ThemeProvider>
  );
}

export default App;
<<< END ./client/src/App.jsx >>>

--- FILE: ./client/package.json ---

<<< BEGIN ./client/package.json >>>
{
  "name": "react-javascript-client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build --watch",
    "preview": "vite preview"
  },
  "dependencies": {
    "@emotion/react": "^11.13.0",
    "@emotion/styled": "^11.13.0",
    "@mui/icons-material": "^5.16.7",
    "@mui/material": "^5.16.7",
    "axios": "^1.7.3",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-markdown": "^9.0.1",
    "react-router-dom": "^6.0.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.37",
    "@types/react-dom": "^18.2.15",
    "@vitejs/plugin-react": "^4.2.0",
    "autoprefixer": "^10.4.20",
    "postcss": "^8.4.45",
    "tailwindcss": "^3.4.10",
    "typescript": "^5.2.2",
    "vite": "^5.0.0"
  }
}

<<< END ./client/package.json >>>

--- FILE: ./client/postcss.config.js ---

<<< BEGIN ./client/postcss.config.js >>>
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

<<< END ./client/postcss.config.js >>>

--- FILE: ./client/tailwind.config.js ---

<<< BEGIN ./client/tailwind.config.js >>>
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}


<<< END ./client/tailwind.config.js >>>

--- FILE: ./client/tsconfig.json ---

<<< BEGIN ./client/tsconfig.json >>>
{
  "compilerOptions": {
    "target": "ESNext",
    "useDefineForClassFields": true,
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "allowJs": false,
    "skipLibCheck": true,
    "esModuleInterop": false,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "Node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "compilerOptions": {
      "baseUrl": ".",
      "paths": {
        "@/*": ["./src/*"]
      }
    }
  },
  "include": ["src"]
}

<<< END ./client/tsconfig.json >>>

--- END FILE CONTENTS ---

--- END REPOSITORY CONTENTS ---
